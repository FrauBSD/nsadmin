#!/bin/sh
#-
# Copyright (c) 2006-2013 Parker Lee Ranney TTEE
# Copyright (c) 2017-2019 Devin Teske <dteske@FreeBSD.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
############################################################ IDENT(1)
#
# $Title: Distributed bind9 administration and management tool $
# $Id: nsadmin,v 1.1 2012/05/09 21:39:43 root Exp $
# $Copyright: 2017-2019 Devin Teske. All rights reserved. $
# $FrauBSD: nsadmin/nsadmin 2019-10-13 20:08:51 -0700 freebsdfrau $
#
############################################################ INFORMATION
#
# nsadmin -- Update Bind's installation on the master NS server. RCS
# 	is used for file history. All updates will be sent out as an
# 	email to the appropriate admin address. A lock is kept during
# 	the run of this program to prevent conflicting updates.
#
# --------------------------------------------------------------------
# Notes:
# 	- Requires bind server and nsadmin.conf on the master.
# 	- Requires nsslave and nsslave-var.inc on the slave Bind
# 	  servers to operate.
# 	- User 'cm' and the authorized_keys2 file for that user must
# 	  be installed on all slave Bind servers. The 'cm' user account
# 	  and ID file must be on the server with this script.
# 	- User 'cm' must be able to remotely execute via SSH the
# 	  following command:
# 		sudo /usr/local/bin/nsslave
# 	  Without password on the slave Bind servers.
# 	- Users must be placed in the DNSOPS group in sudoers as a
# 	  result of the commands that require root access.
# 	  Commands used via sudo: awk chmod chown cp find mv rm service su
# 	- Users must also belong to the "bind" group in /etc/group to
# 	  edit the files.
# --------------------------------------------------------------------
# Version History:
# 	Oct 2019: Release 4.6.5
# 		- Fix TLD record generation
# 	Oct 2019: Release 4.6.4
# 		- Fix error in genconf() when no rev maps exist
# 	Oct 2019: Release 4.6.3
# 		- Fix copy/pasta
# 	Oct 2019: Release 4.6.2
# 		- Minor edit
# 	Oct 2019: Release 4.6.1
# 		- Use sudo to create view directories
# 	Oct 2019: Release 4.6
# 		- Add support for TLD A/AAAA records
# 		- Create $nsadmindir on initial launch
# 	Oct 2019: Release 4.5.9
# 		- Use full paths in genconf()
# 	Oct 2019: Release 4.5.8
# 		- Fix configuration defaults
# 	Oct 2019: Release 4.5.7
# 		- Make mail optional with disabled defaults
# 	Oct 2019: Release 4.5.6
# 		- Make default slaves empty in config
# 	Oct 2019: Release 4.5.5
# 		- Use BSD compatible ANSI escape sequences for printf
# 	Oct 2019: Release 4.5.4
# 		- Fix config
# 	Oct 2019: Release 4.5.3
# 		- Add OS Glue to config for FreeBSD
# 	Oct 2019: Release 4.5.2
# 		- Defer loading of config until after processing options
# 		- Defer check for root until after options processing
# 		- Comments
# 		- Look for config in proper directory based on OS
# 	Oct 2019: Release 4.5.1
# 		- Remove confusing line numbers from named-checkzone output
# 		- Comments and other Minor edits
# 		- Fix version
# 	Oct 2019: Release 4.5
# 		- Make include files for generated zones and rev maps
# 	Oct 2019: Release 4.4.1
# 		- Remove log if exiting due to running as root
# 	Oct 2019: Release 4.4
# 		- Show lock file location when locked
# 		- Do not use sudo in sigquit() if first use fails
# 		- Release lock if exiting due to sudo failure
# 	Oct 2019: Release 4.3
# 		- Fix sync (-s) based checkin from automated edits
# 	Oct 2019: Release 4.2.2
# 		- Add support for vimcat in read-only view mode
# 		- Improve vimcat support with PAGER in all modes
# 	Oct 2019: Release 4.2.1
# 		- Show progress as we generate rev maps
# 		- Only checkin sync'd files on exit if they pass syntax check
# 		- Fix memory leak in genrev()
# 		- Minimally improve and document sudo support
# 	Oct 2019: Release 4.2
# 		- checkin files after sync (-s)
# 	Oct 2019: Release 4.1.1
# 		- Lower sync verbosity
# 	Oct 2019: Release 4.1
# 		- Add support for inline custom TTL preceding protocol family
# 	Oct 2019: Release 4.0.4
# 		- Do not show contextual diff before review
# 		- Add whitespace after main menu prompt
# 	Oct 2019: Release 4.0.3
# 		- Fix rev map synchronization with `-s'
# 		- Trim trailing whitespace on code lines
# 		- Fix spurious error from `cd -' in sigquit()
# 	Oct 2019: Release 4.0.2
# 		- Fix permission issues for members of $bindgroup
# 	Oct 2019: Release 4.0.1
# 		- Fix hang on stdin from RCS co when file is writable
# 	Oct 2019: Release 4.0
# 		- Replace bash arrays with POSIX /bin/sh syntax
# 		- Do not overwrite config files if they exist on install
# 		- Change umask to 0022
# 		- Remove obsolete code
# 		- Improve check for duplicate running instances
# 		- Create required directories if they do not exist
# 		- Optimize usage of "cd" to fix errors
# 		- Improved debugging
# 		- Renamed *-var.inc to *.conf and cleanup
# 		- Merge *.inc files and zone2rev.awk into nsadmin
# 		- Set default view [required] to program basename (nsadmin)
# 		- Add support for `IN' protocol family in master zones
# 		- Fix `-l' to work with `-s'
# 		- Prevent Outlook from eating blank lines in diffs
# 		- Merge nsslave-centos7 into nsslave
# 		- Add support for vimcat
# 		- Add limited ANSI coloring to console output
# 		- Add support for `less -F' when viewing diffs
# 		- Add `-v' to get version
# 	Aug 2019: Release 3.2
# 		- Add Makefile
# 	Jul 2019: Release 3.1
# 		- Initial Public release.
# 		- Enable restriction to prevent anonymous root access.
# 		- Add secondary variable to `nsadmin-var.inc'.
# 		- Fix hard-coded primary/secondary in `GEN FUNCTIONS'.
# 	Jul 2018: Release 3.0
# 		- Major rewrite and code cleanup.
# 		- Improved error checking of zone files.
# 		- Support IPv6 AAAA records.
# 	Jul 2018: Release 2.6
# 		- Fix bug preventing some reverse entries from being created
# 	Jul 2018: Release 2.5
# 		- Fix bug preventing reverse lookup of A records ending in
# 		  .0 or .255
# 	Jul 2017: Release 2.4
# 		- Ask the user for a message to describe changes.
# 		- Only allow one instance of nsadmin at a time.
# 	Jun 2017: Release 2.3
# 		- Add `-n slaves' syntax for selecting a subset of slaves.
# 		- Ported to FreeBSD.
# 	Mar 2010: Release 2.2
# 		- Fixed comments.
# 	Jul 2006: Release 2.1
# 		- Modified to migrate zones manually as IXFR and AXFR
# 		  are not reliable.
# 	Jun 2006: Release 2.0
# 		- Major rewrite and creation of includes.
# 		- Syntax checking.
# 		- Update only the rev maps with a changed IP.
# 		- Added read-only interface.
# 		- Added ability to generate zone files and rev maps
# 		  from the master files without performing updates,
# 		  known as sync.
# 	Apr 2006: Release 1.0
# 		- Basic interface and zone generation.
#
############################################################ INCLUDES

NSADMIN_CONF=nsadmin.conf # See OS Glue

############################################################ GLOBALS

VERSION='$Version: 4.6.5 $'

pgm="${0##*/}" # Program basename
progdir="${0%/*}" # Program directory

PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

#
# Global exit status
#
SUCCESS=0
FAILURE=1

#
# Command-line options
#
syncall=	# -a

#
# OS Glue
#
: ${UNAME_s:=$( uname -s )}

#
# Miscellaneous
#
editmode=				# Run in edit mode
failfile=				# File that failed zonetest()
failtype=				# Type of file that failed
locked=					# Lock obtained by getlock()
ransig=					# Ran sigquit() or not
rootfail=				# Exited due to running as root
sep=$( printf %75s | tr " " - )		# Separator
sepdbl=$( printf %20s | tr " " = )	# Double separator
subnets=				# Subnets changed for rev maps
sudofail=				# No sudo in sigquit() if failed
sync=					# Run in sync mode
synccnt=0				# Number of files sync'd
update=					# Stage of master file updates
updzones=				# Updated zones
vfail=					# Verify failed

############################################################ FUNCTIONS

have(){ type "$@" > /dev/null 2>&1; }

# usage
#
# Print the help menu and exit.
#
usage()
{
	exec >&2
	echo
	echo "  Usage: $pgm ..."
	echo
	echo "    Edit Mode:"
	echo "	Used to edit the master $pgm files:"
	echo
	echo "		$pgm [-n slaves] -e"
	echo
	echo "    Review Mode: (Default)"
	echo "	Used to view the master $pgm files:"
	echo
	echo "		$pgm"
	echo
	echo "    Sync Mode:"
	echo "	Used to update the Bind zone files with the data from"
	echo "	the master $pgm files. This does not allow"
	echo "	editing of the master files:"
	echo
	echo "		$pgm -s [-ah?] [-n slaves] -l <file>[,<file>, ..."
	echo
	echo "		-a			Sync all master files."
	echo "		-l <file>[,<file>]	Sync list of files."
	echo "		-n <slave>[,<slave>]	Override list of slaves."
	echo

	exit $FAILURE
}

############################################################ REV FUNCTIONS
# Functions for generating rev maps from master zones

# zone2rev [-cdilv] $file
#
# Read nsadmin zone $file and produce rev map.
#
# Options:
# 	-c          Enable ANSI color. Implies `-d'
# 	-d          Enable debug messages printed to stderr
# 	-i          Initialize files to zero length
# 	-l          List subnets on stdout and exit
# 	-S          Use sudo
# 	-s subnet   Process only subnet from $file
# 	-V          Verify contents and exit. Implies `-d'
# 	-v view     Process only view from $file
#
exec 9<<'EOF'
function err(str)
{
	if (verify) vstatus = 1
	if (!debug) return
	if (console)
		printf "\033[35m%s\033[36m:\033[32m%d\033[36m:\033[m %s\n",
			file, NR, str > "/dev/stderr"
	else
		printf "%s:%d: %s\n", file, NR, str > "/dev/stderr"
	fflush()
}

# _asorti(src, dest)
#
# Like GNU awk's asorti() but works with any awk(1)
# NB: Named _asorti() to prevent conflict with GNU awk
#
function _asorti(src, dest,        k, nitems, i, idx)
{
	k = nitems = 0
	for (i in src) dest[++nitems] = i
	for (i = 1; i <= nitems; k = i++) {
		idx = dest[i]
		while ((k > 0) && (dest[k] > idx)) {
			dest[k+1] = dest[k]; k--
		}
		dest[k+1] = idx
	}
	return nitems
}

# validate_ipaddr4(ip)
#
# Returns zero if the given argument (an IP address) is of the proper format.
#
# The return value for invalid IP address is one of:
# 	1	One or more individual octets within the IP address (separated
# 		by dots) contains one or more invalid characters.
# 	2	One or more individual octets within the IP address are null
# 		and/or missing.
# 	3	One or more individual octets within the IP address exceeds the
# 		maximum of 255 (or 2^8-1, being an octet comprised of 8 bits).
# 	4	The IP address has either too few or too many octets.
#
function validate_ipaddr4(ip,        octets, noctets, n, octet)
{
	# Split on `dot'
	noctets = split(ip, octets, /\./)
	if (noctets != 4) return 4

	for (n = 1; n <= noctets; n++) {
		octet = octets[n]

		# Return error if the octet is null
		if (octet == "") return 2

		# Return error if not a whole/positive integer
		if (octet ~ /[^0-9]/) return 1

		# Return error if the octet exceeds 255
		if (octet > 255) return 3
	}

	return 0
}

# validate_ipaddr6(ip)
#
# Returns zero if the given argument (an IPv6 address) is of the proper format.
#
# The return value for invalid IP address is one of:
# 	1	One or more individual segments with the IP address
# 		(separated by colons) contains one or more invalid characters.
# 		Segments must contain only combinations of the characters 0-9,
# 		A-F, or a-f.
# 	2	Too many/incorrent null segments. A single null segment is
# 		allowed within the IP address (separated by colons) but not
# 		allowed at the beginning or end (unless a double-null segment;
# 		i.e., "::*" or "*::").
# 	3	One or more individual segments within the IP address
# 		(separated by colons) exceeds the length of 4 hex-digits.
# 	4	The IP address entered has either too few (less than 3), too
# 		many (more than 8), or not enough segments, separated by
# 		colons.
# 	5	The IPv4 address at the end of the IPv6 address is invalid.
#
function validate_ipaddr6(ip,
	segments, nsegments, n, segment, h, short, nulls,
	contains_ipv4_segment, maxsegments)
{
	sub(/%.*$/, "", ip) # remove interface spec if-present

	# Split on `colon'
	nsegments = split(ip, segments, /:/)

	# Return error if too many or too few segments
	# Using 9 as max in case of leading or trailing null spanner
	if (nsegments > 9 || nsegments < 3) return 4

	h = "[0-9A-Fa-f]"
	short = sprintf("^(%s|%s|%s|%s)$", h, h h, h h h, h h h h)

	nulls = contains_ipv4_segment = 0

	for (n = 1; n <= nsegments; n++) {
		segment = segments[n]

		#
		# Return error if this segment makes one null too-many. A
		# single null segment is allowed anywhere in the middle as well
		# as double null segments are allowed at the beginning or end
		# (but not both).
		#
		if (segment == "") {
			nulls++
			if (nulls == 3) {
				# Only valid syntax for 3 nulls is `::'
				if (ip != "::") return 2
			} else if (nulls == 2) {
				# Only valid if begins/ends with `::'
				if (ip !~ /(^::|::$)/) return 2
			}
			continue
		}

		#
		# Return error if not a valid hexadecimal short
		#
		if (segment ~ short) continue # Valid segment of 1-4 hex digits
		if (segment ~ /[^0-9A-Fa-f]/) {
			# Segment contains at least one invalid char

			# Return error immediately if not last segment
			if (n < nsegments) return 1

			# Otherwise, check for legacy IPv4 notation
			if (segment ~ /[^0-9.]/) {
				# Segment contains at least one invalid
				# character even for an IPv4 address
				return 1
			}

			# Return error if not enough segments
			if (nulls == 0) {
				if (nsegments != 7) return 4
			}

			contains_ipv4_segment=1

			# Validate ipv4_segment
			if (validate_ipaddr4(segment)) return 5
		} else {
			# Segment characters are all valid but too many
			return 3
		}
	}

	if (nulls == 1) {
		# Single null segment cannot be at beginning/end
		if (ip ~ /(^:|:$)/) return 2
	}

	#
	# A legacy IPv4 address can span the last two 16-bit segments,
	# reducing the amount of maximum allowable segments by-one.
	#
	maxsegments = contains_ipv4_segment ? 7 : 8

	if (nulls == 0) {
		# Return error if missing segments with no null spanner
		if (nsegments != maxsegments) return 4
	} else if (nulls == 1) {
		# Return error if null spanner with too many segments
		if (nsegments > maxsegments) return 4
	} else if (nulls == 2) {
		# Return error if leading/trailing `::' with too many segments
		if (nsegments > (maxsegments + 1)) return 4
	}

	return 0
}

# split6(ip, array)
#
# Split the elements of IPv6 ip into 32 hex-nibbles stored in array.
#
function split6(ip, nibbles,        n, ip4, octs, s, i, nibs, nib, k)
{
	for (n = 1; n <= 32; n++) nibbles[n] = 0
	if (match(ip, /:[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/)) {
		ip4 = substr(ip, RSTART + 1)
		ip = substr(ip, 1, RSTART - 1)
		split(ip4, octs, /\./)
		ip = sprintf("%s:%02x%02x:%02x%02x",
			ip, octs[1], octs[2], octs[3], octs[4])
	}
	if (sub(/^::/, "", ip)) {
		n = 32
		ip = sprintf("%04s", ip)
		for (k = 4; k > 0; k--) nibbles[n--] = substr(ip, k, 1)
	} else if (sub(/::$/, "", ip)) {
		n = 1
		ip = sprintf("%04s", ip)
		for (k = 1; k <= 4; k++) nibbles[n++] = substr(ip, k, 1)
	} else if (ip ~ /::/) {
		left = right = ip
		sub(/::.*$/, "", left)
		sub(/^.*::/, "", right)
		s = split(left, nibs, /:/)
		for (i = 1; i <= s; i++) {
			n = (i - 1) * 4 + 1
			nib = sprintf("%04s", nibs[i])
			for (k = 1; k <= 4; k++)
				nibbles[n++] = substr(nib, k, 1)
		}
		s = split(right, nibs, /:/)
		n = 32
		for (i = s; i > 0; i--) {
			nib = sprintf("%04s", nibs[i])
			for (k = 4; k > 0; k--)
				nibbles[n--] = substr(nib, k, 1)
		}
	} else {
		s = split(ip, nibs, /:/)
		for (i = 1; i <= s; i++) {
			n = (i - 1) * 4 + 1
			nib = sprintf("%04s", nibs[i])
			for (k = 1; k <= 4; k++)
				nibbles[n++] = substr(nib, k, 1)
		}
	}
}

BEGIN {
	if (console || verify) debug = 1
	vstatus = 0

	subnet = tolower(subnet)
	delete initialized
	delete files
	NR = 0
	rec = ""
	while (getline < file > 0) {
		NR++
		if (/^[[:space:]]*;/) continue
		if ($1 ~ "^" file) continue
		if (/;*VIEW:/ && $0 !~ view) continue
		if (/\*/) continue
		gsub(/;.*/, "")
		delete U
		for (n = 1; n <= 5 && n <= NF; n++) U[n] = toupper($n)
		if (NF == 2) {
			type = U[1]
			ip = $2
		} else if (NF == 3) {
			if ($1 !~ /^([0-9]+|IN)$/) rec = $1
			type = U[2]
			ip = $3
		} else if (NF == 4 && U[2] ~ /^([0-9]+|IN)$/) {
			if ($1 !~ /^[0-9]+$/) rec = $1
			type = U[3]
			ip = $4
		} else if (NF == 5 && $2 ~ /^[0-9]+$/ && U[3] == "IN") {
			rec = $1
			type = U[4]
			ip = $5
		} else {
			continue
		}
		if (type == "A") {
			if ((errno = validate_ipaddr4(ip)) != 0) {
				err(sprintf("bad A record `%s' for `%s' " \
					"(ERR#%u)", ip, rec, errno))
				continue
			}
			split(ip, oct, /\./)
			net = sprintf("%u.%u.%u", oct[1], oct[2], oct[3])
			if (!list_subnets && subnet && net != subnet) continue
			rev = sprintf(".new-%u.%u.%u", oct[3], oct[2], oct[1])
			ptr = sprintf("%u\t\t\t\t\tPTR\t%s%s%s.",
				oct[4], rec, rec == "" ? "" : ".", file)
		} else if (type == "AAAA") {
			if ((errno = validate_ipaddr6(ip)) != 0) {
				err(sprintf("bad AAAA record `%s' for `%s' " \
					"(ERR#%u)", ip, rec, errno))
				continue
			}
			delete nib
			split6(ip, nib)
			net = sprintf("%s%s%s%s:%s%s%s%s:%s%s%s%s:%s%s%s%s",
				nib[1], nib[2], nib[3], nib[4],
				nib[5], nib[6], nib[7], nib[8],
				nib[9], nib[10], nib[11], nib[12],
				nib[13], nib[14], nib[15], nib[16])
			if (!list_subnets && subnet && tolower(net) != subnet)
				continue
			rev = tolower(sprintf(".new-" \
				"%s.%s.%s.%s." \
				"%s.%s.%s.%s." \
				"%s.%s.%s.%s." \
				"%s.%s.%s.%s",
				nib[16], nib[15], nib[14], nib[13],
				nib[12], nib[11], nib[10], nib[9],
				nib[8], nib[7], nib[6], nib[5],
				nib[4], nib[3], nib[2], nib[1]))
			ptr = sprintf( \
				"%s.%s.%s.%s." \
				"%s.%s.%s.%s." \
				"%s.%s.%s.%s." \
				"%s.%s.%s.%s" \
				"\t\tPTR\t%s%s%s.",
				nib[32], nib[31], nib[30], nib[29],
				nib[28], nib[27], nib[26], nib[25],
				nib[24], nib[23], nib[22], nib[21],
				nib[20], nib[19], nib[18], nib[17],
				rec, rec == "" ? "" : ".", file)
		} else {
			continue
		}
		if (list_subnets) {
			subnets[net] = 1
			continue
		}
		if (initialize && !(rev in initialized)) {
			printf "" > rev
			initialized[rev] = 1
		}
		files[rev] = 1
		print ptr >> rev
	}
	exit
}

END {
	if (verify) exit vstatus
	if (list_subnets) {
		n = _asorti(subnets, subnets_sorted)
		for (i = 1; i <= n; i++) print subnets_sorted[i]
		exit
	}

	if (!debug) exit
	fmt = console ? "\033[32m%5d\033[36m:\033[m %s\n" : "%5d: %s\n"
	n = _asorti(files, files_sorted)
	for (i = 1; i <= n; i++) {
		rev = files_sorted[i]
		if (console)
			printf "\033[32m>\033[m %s\n", rev > "/dev/stderr"
		else
			printf "> %s\n", rev > "/dev/stderr"
		while (getline < rev > 0)
			printf fmt, ++NRr[rev], $0 > "/dev/stderr"
	}
}
EOF
zone2rev_awk=$( cat <&9 )
zone2rev()
{
	local console=0
	local debug=0
	local initialize=0
	local list_subnets=0
	local subnet=
	local sudo=
	local verify=0
	local view=
	local OPTIND=1 OPTARG flag

	while getopts cdilSs:Vv: flag; do
		case "$flag" in
		c) console=1 ;;
		d) debug=1 ;;
		i) initialize=1 ;;
		l) list_subnets=1 ;;
		S) sudo=1 ;;
		s) subnet="$OPTARG" ;;
		V) verify=1 ;;
		v) view="$OPTARG" ;;
		esac;
	done
	shift $(( $OPTIND - 1 ))

	${sudo:+sudo} awk -v console=$console \
		-v debug=$debug \
		-v file="$1" \
		-v initialize=$initialize \
		-v list_subnets=$list_subnets \
		-v subnet="$subnet" \
		-v verify=$verify \
		-v view="$view" \
		"$zone2rev_awk"
}

############################################################ EDIT FUNCTIONS
# Functions to edit/change master files for zone and rev maps

# editmaster zone
#
# Edit the master files.
#
editmaster()
{
	local file="$1"

	log -d "Editing $file"

	cd "$nsadmindir"
	checkout "$file"

	${EDITOR:-vi} "$file"
	verify "$file"

	cd - > /dev/null
}

# getlock
#
# Establish an exclusive lock for master file edits.
#
getlock()
{
	local clobber=
	local res

	if [ -f "$lock" ]; then
		res=$( ls -l "$lock" | awk '{print $3}' )
		printf "\033[2mlock: %s\033[m\n" "$lock"
		fatal "lock file exists, owner is $res" # NOTREACHED
	fi

	[ "$-" = "${-#*C}" ] && clobber=1
	set -C
	echo $$ > "$lock" || fatal "could not create '$lock'" # NOTREACHED
	[ "$clobber" ] && set +C
	locked=1
}

# predit
#
# Prepare the editing of the master files.
#
predit()
{
	local dir

	trap "sigquit; exit" EXIT SIGHUP SIGINT SIGQUIT SIGTERM

	msg "$USER starting edits: $( date )"

	if ! sudo rm -rf "$lock" "$log" "$tmp" .bak-* .revunq .updzones .view*
	then
		sudofail=rm
		exit $FAILURE
	fi

	echo > "$log"
	log " Starting: $( date )"

	mkdir -p -m 0770 "$tmp"

	# Make tmp directory owned by BIND user/group and group-writable
	dir="$tmp"
	case "$dir" in
	*/) dir="${dir%/}" ;;
	esac
	dir="${dir%/*}"
	case "$dir" in
	/) : skip ;;
	*) sudo chown -R "$binduser:$bindgroup" "$dir"
	   sudo chmod -R g+w "$dir"
	esac
}

# clear
#
# Like clear(1) but preserve scrollback.
#
clear()
{
	local size rows cols
	size=$( stty size 2> /dev/null )
	set -- ${size:-24 80}
	rows="$1"
	cols="$2"
	printf "\033[${rows}S\033[H"
}

############################################################ GEN FUNCTIONS
# Functions to generate zone files and reverse maps

# genmaster
#
# Generate the zone files and rev maps.
#
genmaster()
{
	local ans
	local file
	local subnet

	#
	# Save the master files that have changes to make sure they
	# are not lost in the loop'ing below.
	#
	echo "$updzones" > "$nsadmindir/.updzones"

	#
	# Generate a list of all subnets in the master file
	#
	if [ "$sync" ]; then
		for subnet in $(
			for file in $updzones; do
				zone2rev -l "$file"
			done | sort -u
		); do
			# Only insert subnet if not existing in $subnets
			echo "$subnets" | grep -q "\\<$(
				echo "$subnet" | sed -e 's/\./\\&/g'
			)$subnet\\>" || subnets="$subnets $subnet"
		done
		subnets="${subnets# }"
	fi

	#
	# Loop through the zone file generation until each error is
	# fixed. Slave systems will not sync bad zone files nor will
	# the master load them.
	#
	while :; do
		echo
		msg "Building zone files and revmaps: $( date )"
		genzone $( cat "$nsadmindir/.updzones" )
		genrev

		zonetest
		[ "$failfile" ] || break

		printf "\n\033[1mPress return when ready to re-edit.\033[m"
		stty -echo
		read ans # ignored
		stty echo

		# Clean up the previous attempt
		find "$tmp" -type f -exec rm -f {} \;

		#
		# XXX Use the rcsdiff output to find the correct
		# XXX zone to edit instead of relying on the user to
		# XXX remember which file had errors.
		#
		if [ "$failtype" = rev ]; then
			zonemenu
		else
			editmaster "$failfile"
		fi
	done
}

# genrev
#
# Generate the reverse maps.
#
genrev()
{
	local excl
	local file
	local list
	local n
	local origin
	local rev
	local revfile
	local subnet
	local t
	local view
	local zone2rev_debug

	cd "$nsadmindir"
	for view in $views; do
		msg " VIEW: $view/rev"

		list="${updzones:-$( ls -d [a-z0-9]* )}"
		for excl in $exclude; do
			list=$( echo "$list" | sed -e "s/$excl//" )
		done

		n=1
		t=$( set -- $list; echo $# )
		zone2rev_debug=
#?		[ "$sync" ] && zone2rev_debug=-d # Testing -- Devin
		for file in $list; do
			printf "  \033[2m%-30s \033[1m%4u/%-4u\033[m\n" \
				"[$file]" $n $t
			for subnet in $subnets; do
#?				printf "  \033[3m-> $subnet\033[m\n"
#?					# Testing -- Devin
				zone2rev -S $zone2rev_debug \
					-v "$view" -s "$subnet" "$file"
			done
#?			echo # Testing -- Devin
			n=$(( $n + 1 ))
		done
		echo

		for file in .new-*; do
			[ -e "$file" ] || continue

			revfile=$( echo "$file" | sed -e "s/^.new-//" )
			case "$revfile" in
			*.*.*.*.*) origin="$revfile.ip6.arpa." ;;
			*) origin="$revfile.in-addr.arpa." ;;
			esac
			rev="$tmp/$view/rev/$revfile"

			revunq "$file"

			awk 'sub(/^\\t/,"\t")||1' > "$rev" <<-EOF
			\$TTL $ttl
			@ IN SOA $primary. $contact. (
			\t		$serial	; serial
			\t		$refresh		; refresh
			\t		$retry		; retry
			\t		$expire		; expire
			\t		$minimum )		; minimum
			\t		IN NS $primary.
			\t		IN NS $secondary.
			\$ORIGIN $origin
			EOF
			grep -v ";" "$file" >> "$rev"

			rm -f "$file"
		done
	done
	cd - > /dev/null
}

# genzone zone ...
#
# Generate the master zone files.
#
genzone()
{
	local file
	local list="$*" # edited zones
	local origin
	local view

	for view in $views; do
		mkdir -p -m 0770 "$tmp/$view/master" "$tmp/$view/rev"
	done

	for view in $views; do
		msg " VIEW: $view/master"
		cd "$tmp/$view/master"

		for file in $list; do
			printf "  \033[2m-> $file\033[m\n"
			origin="$file."

			awk 'sub(/^\\t/,"\t")||1' > "$file" <<-EOF
			\$TTL $ttl
			@ IN SOA $primary. $contact. (
			\t		$serial	; serial
			\t		$refresh		; refresh
			\t		$retry		; retry
			\t		$expire		; expire
			\t		$minimum )		; minimum
			\t		IN NS $primary.
			\t		IN NS $secondary.
			\$ORIGIN $origin
			EOF

			#
			# Keep any semicolons within a quoted TXT
			# record. Clear away all others.
			#
			awk -v view="$view" '
			!/^[[:space:]]*(;|$)/ {
				if (/;*VIEW:/ && $0 !~ view) next
				if (/".*;.*"/)
					sub(/; VIEW:.*/, "")
				else
					sub(/;.*/, "")
				print
			}' "$nsadmindir/$file" >> "$file"
		done

		cd - > /dev/null
	done

	sudo chown -R "$binduser:$bindgroup" "$tmp/$view"
	sudo chmod -R g+w "$tmp/$view"
}

# revunq file
#
# Generate a rev map file with unique PTR records based on resulting hostname
# pointers.
#
revunq()
{
	local file="$1"

	awk -v file="$file" '
	function posnum(str)
	{
		if (str ~ /ns[0-9]*\.example\.com/) return 6
		if (str ~ /mx[0-9]*\.googlemail\.com/) return 6
		if (str ~ /\..*\.example\.com/) return 5
		if (str ~ /\.example\.com/) return 4
		if (str ~ /\.example\./) return 3
		return 1
	}
	BEGIN {
		delete host
		while (getline < file > 0) {
			if (!($1 in host)) host[$1] = $3
			else if (posnum(host[$1]) < posnum($3)) host[$1] = $3
		}
		for (unit in host) printf("%s%s\t\tPTR\t%s\n",
			unit, length(unit) <= 3 ? "\t\t\t" : "", host[unit])
	}
	' > .revunq

	sudo mv .revunq "$file"
}
 
# genconf view ...
#
# Make BIND include files of generated zones and rev maps for each given view.
#
genconf()
{
	local view file zone master_conf rev_conf
	local prefix='^[[:space:]]*$ORIGIN\>.*'
	local suffix='\.arpa\.\([[:space:]]\|$\)'
	local ip4arpa="$prefix"'\.in-addr'"$suffix"
	local ip6arpa="$prefix"'\.ip6'"$suffix"

	cd "$nameddir" || return
	for view in "$@"; do
		mkdir -p -m 0770 "$view/include"
		sudo chown "$binduser:$bindgroup" "$view/include"

		# Generate master.conf include for view
		master_conf="$view/include/master.conf"
		:| sudo tee "$master_conf"
		for file in "$nameddir/$view"/master/*; do
			[ -e "$file" ] || continue
			zone="${file##*/}"
			{
				printf 'zone "%s" in {\n' "$zone"
				printf '\ttype master;\n'
				printf '\tfile "%s";\n' "$file"
				printf '\tnotify yes;\n'
				printf '};\n'
			} | sudo tee -a "$master_conf" > /dev/null
		done

		# Generate rev.conf include for view
		rev_conf="$view/include/rev.conf"
		:| sudo tee "$rev_conf"
		for file in "$nameddir/$view"/rev/*; do
			[ -e "$file" ] || continue
			zone="${file##*/}"
			grep -q "$ip4arpa" "$file" && {
				printf 'zone "%s.in-addr.arpa" in {\n' "$zone"
				printf '\ttype master;\n'
				printf '\tfile "%s";\n' "$file"
				printf '\tnotify yes;\n'
				printf '};\n'
			} | sudo tee -a "$rev_conf" > /dev/null
			grep -q "$ip6arpa" "$file" && {
				printf 'zone "%s.ip6.arpa" in {\n' "$zone"
				printf '\ttype master;\n'
				printf '\tfile "%s";\n' "$file"
				printf '\tnotify yes;\n'
				printf '};\n'
			} | sudo tee -a "$rev_conf" > /dev/null
		done
	done
	cd - > /dev/null
}

############################################################ OP FUNCTIONS
# Functions to operate dns change mechanism and interact with user

# dnsreload
#
# Reload the master Bind named process.
#
dnsreload()
{
	local file
	local res
	local view

#?	clear # Testing -- Parker
	sep "# nsadmin: Local Bind Reload"
	msg "Reloading Bind: $( date )"

	echo
	sudo service named restart
	sleep 1
	if ! pgrep named > /dev/null; then
		msg "ERROR: named is not running after reload: $( date )"

		msg "ERROR: attempting manual restart: $( date )"
		sudo service named start
		if pgrep named > /dev/null; then
			msg "Manual restart succeeded: $( date )"
			update=0
			return
		fi

		msg "ERROR: manual restart failed: $( date )"
		msg "ERROR: attempting to roll-back: $( date )"

		cd "$nameddir"
		for view in $views; do
			for file in $( find "$view" -name ".bak-*" ); do
				res=$( echo "$file" | sed -e "s/.bak-//" )
				sudo mv "$file" "$res"
			done
		done
		cd - > /dev/null

		sudo service named start
		if pgrep named > /dev/null; then
			msg "Roll-back succeeded: $( date )"
			update=0
			return
		fi

		if [ "$critical" ]; then
			echo "$USER: $( date )" |
				mail -s "nsadmin: roll-back failed" "$critical"
		fi
		fatal "roll-back failed ... giving up" # NOTREACHED
		update=2

	fi

	update=0 # successful update/reload
}

# fatal $text ...
#
# Generate a fatal error message and exit this program.
#
fatal()
{
	logger -p user.crit -t "FATAL ERROR" "$*"
	echo
	echo " Fatal Error: $*" | tee -a "$log"
	echo
	[ "$rootfail" ] && rm -f "$log"
	exit $FAILURE
}

# sep [-dn] [-c color] $text ...
#
# Generate a separator on stdout.
#
sep()
{
	local color="34;"
	local sepsep="$sep"
	local OPTIND=1 OPTARG flag

	while getopts c:dn flag; do
		case "$flag" in
		c) color="$OPTARG${OPTARG:+;}" ;;
		d) sepsep="$sepdbl" ;;
		n) sepsep= ;;
		esac
	done
	shift $(( $OPTIND - 1 ))

	printf "\033[%s1m%s\n%s\n%s\n\033[m\n" \
		"$color" "$sepsep" "$*" "$sepsep"
}

# log [-dn] $text ...
#
# Generate a separator in the log.
#
log()
{
	local logsep="$sep"
	local OPTIND=1 OPTARG flag

	while getopts dn flag; do
		case "$flag" in
		d) logsep="$sepdbl" ;;
		n) logsep= ;;
		esac
	done
	shift $(( $OPTIND - 1 ))

	printf "%s\n%s\n%s\n\n" "$logsep" "$*" "$logsep" >> "$log"
}

# msg $text ...
#
# Generate a message in terminal, log file, and syslog.
#
msg()
{
	local msg="$*"

	printf "\n%s\n\n" "$msg"
	printf "\n%s\n\n" "$msg" >> "$log"
	logger -p user.info -t Info "$msg"
}

# sigquit
#
# Process a set of commands when a signal is caught by trap.
#
sigquit()
{
	local date
	local excl
	local file
	local res
	local skip
	local subj

	[ "$ransig" ] && return

	stty echo
	echo

	LESSSECURE=

	cd "$nsadmindir"

	if [ ${update:=0} -eq 1 ]; then
		msg "ERROR: nsadmin killed after changes were" \
		    "made to master files: rolling back"
		for file in .bak-*; do
			[ -e "$file" ] || continue
			res=$( echo "$file" | sed -e s/.bak-// )
			cp "$file" "$res" > /dev/null 2>&1
		done
		checkin
		subj="nsadmin: ERROR: $( date ): $USER"
	elif [ ${update:=0} -eq 2 ]; then
		msg "ERROR: nsadmin killed after files were" \
		    "updated in the NAMEDB directory: rolling back"
		for file in .bak-*; do
			[ -e "$file" ] || continue
			res=$( echo "$file" | sed -e s/.bak-// )
			cp "$file" "$res"
		done
		checkin
		msg "ERROR":" rolling back NAMEDB zone files"
		subj="nsadmin: ERROR: $( date ): $USER"
	else
		checkin
		subj="nsadmin: $( date ): $USER"
	fi

	date=$( date )
	sep -n -c 2 " Finished: $date"
	echo >> "$log"
	log " Finished: $date"
	if [ "$admin" ]; then
		cat "$log" | mail -s "$subj" "$admin"
	fi

	if [ ! "$sudofail" ]; then
		sudo rm -rf "$lock" "$log" "$tmp" \
			.bak-* .revunq .updzones .view*

		# XXX Save the older version in case of emergency.
		#sudo find "$nameddir" -name ".bak-*" -exec rm -f {} \;
	elif [ "$locked" ]; then
		rm -f "$lock"
		locked=
	fi

	#
	# Make sure files are not left in a write state as it will
	# generate errors.
	#
	for file in *; do
		[ -e "$file" ] || continue
		skip=
		for excl in $exclude; do
			[ "$file" = "$excl" ] || continue
			skip=1
			break
		done
		[ "$skip" ] || chmod a-w "$file" > /dev/null 2>&1
	done

	cd - > /dev/null 2>&1

	ransig=1
}

# zonemenu
#
# Print the list of zones and prompt for user selection.
#
zonemenu()
{
	local zone

	while :; do
		zonelist

		printf "\n\033[1m Please choose a zone to"
		if [ "$editmode" ]; then
			printf " edit "
		elif [ "$sync" ]; then
			printf " sync "
		else
			printf " view "
		fi
		printf "or 'q' to quit:\033[m "
		read zone
		echo

		if [ "$zone" = Q ] || [ "$zone" = q ]; then
			break
		fi

		echo
		if [ ! "$zone" ] || [ ! -f "$zone" ]; then
			msg "Zone file not found: '$zone'"
			continue
		fi

		if [ "$editmode" ]; then
			cp "$zone" ".bak-$zone" > /dev/null 2>&1
			editmaster "$zone"
		elif [ "$sync" ]; then
			if [ "$updzones" ]; then
				if ( ! echo "$updzones" | egrep \
		    		    "(^| |	)$zone(	| |$)" \
		    		    > /dev/null 2>&1 ); then
					updzones="$updzones $zone"
				fi
			else
				updzones="$zone"
			fi
		else
			if have vimcat; then
				vimcat "$zone" | ${PAGER:-less -r}
			else
				${PAGER:-less} "$zone"
			fi
		fi
	done
}

############################################################ ZONE FUNCTIONS
# Functions to interact with master files and generated zones

# checkin
#
# Using RCS, check in the edited and verified master files.
#
checkin()
{
	local cnt=1
	local file rcsfile

	while eval [ \"\$colist_$cnt\" ]; do
		eval file=\"\$colist_$cnt\"
		case "$file" in
		/*) rcsfile="${file%/*}/RCS/${file##*/},v" ;;
		 *) rcsfile="RCS/$file,v"
		esac
		sudo chown "$binduser:$bindgroup" "$file"
		sudo chmod 0440 "$file"
		[ "$sync" ] && rcs -l "$file"
		echo "$USER: $( date )" | ci -u "$file" #? > /dev/null 2>&1
		sudo chown "$binduser:$bindgroup" "$rcsfile"
		sudo chmod 0660 "$rcsfile"
		cnt=$(( $cnt + 1 ))
	done
}

# checkout file
#
# Using RCS, check out the master file for editing.
#
checkout()
{
	local cnt=1
	local file="$1"

	while eval [ \"\$colist_$cnt\" ]; do
		eval [ \"\$file\" = \"\$colist_$cnt\" ] && return
		cnt=$(( $cnt + 1 ))
	done

	eval colist_$cnt=\"\$file\"
	sudo chown "$USER" "$file"
	sudo chmod 0440 "$file"
	:| co -l "$file" > /dev/null 2>&1
}

# getsubnets file
#
# Get only the subnets that changed in the master file edit.
#
getsubnets()
{
	local file="$1"
	local subnet

	for subnet in $( rcsdiff -uq "$file" | awk 'NR>2&&sub(/^[+-]/,"")' |
		zone2rev -l - )
	do
		# Only insert subnet if not existing in $subnets
		echo "$subnets" | grep -q "\\<$(
			echo "$subnet" | sed -e 's/\./\\&/g'
		)$subnet\\>" || subnets="$subnets $subnet"
	done
	subnets="${subnets# }"
}

# pushzones
#
# Update the Bind zone files with the finished master files.
#
pushzones()
{
	local cmd
	local file
	local res
	local slave
	local view

#?	clear # Testing -- Parker
	sep "# nsadmin: Zone Push"
	msg " Executing local Push:"

	msg "	Backing up previous versions: $( date )"
	cd "$nameddir"
	for view in $views; do
		if [ ! -e "$view" ]; then
			sudo mkdir -p -m 1770 "$view"
			sudo chown "$binduser:$bindgroup" "$view"
		fi
		for dir in "$view/master" "$view/rev"; do
			[ ! -e "$dir" ] || continue
			mkdir -p -m 0770 "$dir"
			sudo chown "$binduser:$bindgroup" "$dir"
		done
		for file in $( find "$view" -type f ! -name ".bak-*" ); do
			res=$( echo "$file" |
			    sed -e 's/\(.*\/\)\(.*\)/\1.bak-\2/' )
			sudo cp "$file" "$res"
		done
	done
	cd - > /dev/null

	msg "	Pushing local zones: $( date )"
	cd "$tmp"
	sudo chown -R "$binduser:$bindgroup" *
	sudo chmod -R g+w *
	find . -type f -exec sudo cp {} "$nameddir/{}" \;
	cd - > /dev/null

	msg "	Generating configs: $( date )"
	genconf $views

	msg "	Building zone tarball: $( date )"
	cd "$tmp"
	tar czpf zone.tgz *
	cd - > /dev/null
#?	sleep 2 # Testing -- Parker

	for slave in $slaves; do
#?		clear # Testing -- Parker
		sep "# nsadmin: Zone Push"
		msg " Executing remove push to $slave: $( date )"

		msg "	Copying zone tarball to $slave: $( date )"
		cmd="scp $scpopts $tmp/zone.tgz $user@$slave:tmp"
		sudo su - $user -c "$cmd"

		msg "	Executing push on $slave: $( date )"
		cmd="ssh $sshopts $slave"
		cmd="$cmd 'sudo /usr/local/bin/nsslave'"
		sudo su - $user -c "$cmd"

#?		sleep 2 # Testing -- Parker
	done
}

# verify file
#
# Verify changes in the zone files.
#
verify()
{
	local ans
	local diff
	local file="$1"
	local res

	if rcsdiff -q "$file" > /dev/null 2>&1; then
		ci -u "$file" > /dev/null 2>&1
		msg "No changes made to $file."
		stty -echo
		echo " Press return to continue."
		read ans # Ignored
		stty echo
		return
	fi

	if res=$( zone2rev -V "$file" ); then
		vprompt "$file"
		return
	fi

	clear
	sep "# nsadmin: Verify Failure"
	msg "ERROR: incorrect A/AAAA record format"
	echo

	echo "$res" | tee -a "$log"
	diff=$( rcsdiff -u "$file" )
	if have vimcat; then
		echo "$diff" | vimcat | ${PAGER:-less -F -r}
	else
		echo "$diff" | ${PAGER:-less -F}
	fi
	echo "$diff" | awk '$0="  "$0' >> "$log"
	echo >> "$log"

	echo
	echo
	stty -echo
	echo " Press return to continue."
	read ans # Ignored
	stty echo

	editmaster "$file"
}

# viewtest zone
#
# Test the view syntax in the master files.
#
viewtest()
{
	local file="$nsadmindir/$1"
	local view

	cat <<-EOF

	 Testing View Syntax:

	EOF

	rm -f .view*

	grep --line-number VIEW "$file" > .view
	grep -v "; VIEW: " .view >> .view-out
	grep , .view | grep -v ", " >> .view-out

	grep "; VIEW: " .view |
		sed -e "s/.*VIEW: //;s/,//g" > .view-list
	for view in $views; do
		sed -e "s/$view//g" .view-list > .n
		mv .n .view-list
	done
	egrep -v '^( $|$)' .view-list > .n
	mv .n .view-list

	# XXX YUK
	if [ -s .view-out ] || [ -s .view-list ]; then
		if [ -s .view-out ]; then
			sed -e 's/^\([0-9]*\):/line \1: /;s/^/	/' .view-out
			echo
			msg "ERROR: invalid view syntax, must use" \
			    "'; VIEW: <view>[, <view> ...]'"
		fi

		if [ -s .view-list ]; then
			sed -e "s/^/	unknown view: /" .view-list
			echo
			msg "ERROR: unknown views, valid views are" "'$views'"
		fi

		failtype=master
		failfile="$1"

		return
	fi

	# checkin file on exit in sync mode (-s)
	if [ "$sync" ];then
		synccnt=$(( $synccnt + 1 ))
		eval colist_$synccnt=\"\$1\"
	fi

	echo "	OK"
	echo
}

# vprompt file
#
# User interaction within the verify() function.
#
vprompt()
{
	local ans
	local diff
	local file="$1"

	clear
	sep "# nsadmin: $file changes"

	diff=$( rcsdiff -u "$file" )
	if have vimcat; then
		echo "$diff" | vimcat | ${PAGER:-less -F -r}
	else
		echo "$diff" | ${PAGER:-less -F}
	fi
	echo "$diff" | awk '$0="  "$0' >> "$log"
	echo >> "$log"

	printf "\n\n"
	printf " \033[1mAccept these changes [(y)es | (n)o | (E)dit]:\033[m "
	read ans
	echo

	case "$ans" in
	[nN])	msg "$USER canceled changes: $( date )"
		cp ".bak-$file" "$file" > /dev/null 2>&1
		;;
	[yY])	echo
		msg "$USER accepted changes: $( date )"
		getsubnets "$file"
		update=1 # First stage of dns updates
		if [ "$updzones" ] && ! echo "$updzones" |
		    egrep "(^| |	)$file(	| |$)" > /dev/null 2>&1
		then
			updzones="$updzones $file"
		else
			updzones="$file"
		fi
		echo
		;;
	*)	msg "$USER re-editing $file; $( date )"
		editmaster "$file"
	esac
}

# zonelist
#
# List the currently active zones.
#
zonelist()
{
	local cnt
	local col=0
	local tab=
	local zone

	clear
	sep "# nsadmin: Zone List"

	for zone in [a-z0-9]*; do
		[ -e "$zone" ] || continue
		if echo "$exclude" |
		    egrep "(^| |	)$zone(	| |$)" \
		    > /dev/null 2>&1
		then
			continue
		fi

		cnt=$(( ${#zone} + 1 ))
		if [ $cnt -lt 7 ]; then
			tab='\t\t\t'
		elif [ $cnt -lt 15 ]; then
			tab='\t\t'
		else
			tab='\t'
		fi
		if [ $col -ge 3 ]; then
			echo
			col=0
		fi
		printf "  %s$tab" "$zone"
		col=$(( $col + 1 ))
	done
	printf "\n\n"
}

# zonetest
#
# Test the generated zones and rev maps.
#
zonetest()
{
	local file
	local _IFS="$IFS" IFS
	local res

	failfile=
	failtype=

	for file in $( find "$tmp" -type f ); do
		IFS=/
		set -- ${file#"$tmp/"}
		IFS="$_IFS"

#?		clear # Testing -- Devin
		sep "# nsadmin: Zone Tests"
		cat <<-EOF
		 View:	$1
		 Type:	$2
		 Zone:	$3

		EOF

		if [ "$2" = master ]; then
			viewtest "$3"
			[ "$failtype" ] && return
		fi

		echo
		echo " Testing Bind Syntax:"

		if ! res=$( exec 2>&1
			name="$3"
			if [ "$2" = rev ]; then
				if [ "$3" != "${3#*.*.*.*.*}" ]; then
					name="$name.ip6.arpa"
				else
					name="$name.in-addr.arpa"
				fi
			fi
			( named-checkzone "$name" "$file" 2>&1;
			  echo :EXIT:$?
			) | awk '
				sub(/^:EXIT:/, "") { status = $0; next }
				match($0, /^[^[:space:]:]+:[0-9]+:/) {
					prefix = substr($0, 1, RLENGTH - 1)
					suffix = substr($0, RSTART + RLENGTH)
					sub(/[0-9]+$/, "", prefix)
					sub(".*/", "", prefix)
					$0 = prefix suffix
				}1
				END { exit status }
			' # END-QUOTE
		) && [ $( echo "$res" | wc -l ) -gt 2 ]; then
			failtype="$2"
			failfile="$3"

			echo "$res" | sed -e 's/.*\///;s/^/	/'
			echo

			echo
			echo " Master File Diff:"
			rcsdiff -u "$nsadmindir/$3" 2>&1 |
				sed -e "s/^/	/"
			echo

			msg "ERROR: zone test failed on $failfile"

			return
		fi

		echo "$res" | sed -e "s/^/	/"
		echo

#?		sleep 2 # Testing -- Parker
	done
}

############################################################ MAIN

#
# Process command-line options
#
while getopts "aehl:n:sv?" flag; do
	case "$flag" in
	a) syncall=1 ;;
	e) editmode=1 ;;
	l) updzones=$( echo "$OPTARG" | sed -e "s/,/ /g" ) ;;
	n) slaves=$( echo "$OPTARG" | sed -e "s/,/ /g" ) ;;
	s) sync=1 ;;
	v) VERSION="${VERSION#*: }"
		echo "${VERSION% $}"
		exit $SUCCESS ;;
	*) usage # NOTREACHED
	esac
done
shift $(( OPTIND - 1 ))

# $USER required for all logging and auditability
if [ "${USER:=$( id -nu )}" = root ]; then
	rootfail=1
	fatal "root is forbidden to use nsadmin" # NOTREACHED
fi

#
# OS Glue
#
case "$UNAME_s" in
*BSD*) NSADMIN_CONF="/usr/local/etc/$NSADMIN_CONF" ;;
*) NSADMIN_CONF="/etc/$NSADMIN_CONF"
esac

#
# Load config
#
. "$NSADMIN_CONF" || exit

#
# Setup
#
if [ ! -e "$nsadmindir" ]; then
	printf "\n\033[2m Setting up...\033[m\n\n"
	case "$nsadmindir" in
	*/*)
		parentdir="${nsadmindir%/*}"
		if [ ! -e "$parentdir" ]; then
			if ! sudo mkdir -p -v "$parentdir"; then
				sudofail=mkdir
				exit $FAILURE
			fi
		fi
		unset parentdir
		;;
	esac
	if ! sudo mkdir -p -v -m 1770 "$nsadmindir"; then
		sudofail=mkdir
		exit $FAILURE
	fi
	if ! sudo chown "$binduser:$bindgroup" "$nsadmindir"; then
		sudofail=mkdir
		exit $FAILURE
	fi
fi
cd "$nsadmindir" || exit

#
# Configuration defaults
#
: ${views:=$pgm}

#
# Process -a
#
if [ "$syncall" ]; then
	for file in *; do
		[ -e "$file" ] || continue
		skip=
		for excl in $exclude; do
			[ "$file" = "$excl" ] || continue
			skip=1
			break
		done
		if [ ! "$skip" ] && [ ! "$updzones" ]; then
			updzones="$file"
		elif [ ! "$skip" ]; then
			updzones="$updzones $file"
		fi
	done
fi

#
# Validate command-line arguments
#
if [ "$updzones" ] && [ ! "$sync" ]; then
	msg "ERROR: '-l' or '-a' requires '-s'"
	usage # NOTREACHED
fi

umask 0022
LESSSECURE=1 # Disable edit functions

#
# Check for duplicate instances
#
pids=
for pid in $( pgrep -f "/bin/(ba)?sh $0([[:space:]]|$)" 2> /dev/null ); do
        case "$pid" in $$|$PPID) continue; esac
        ps -p $pid > /dev/null 2>&1 || continue
        pids="$pids $pid"
done
if [ "$pids" ]; then
        echo "Already running:" $pids
        exit $FAILURE
fi

#
# Setup
#
if [ ! -e "$nsadmindir/RCS" ]; then
	mkdir -p -m 0770 "$nsadmindir/RCS"
	if ! sudo chown "$bindgroup:$binduser" "$nsadmindir/RCS"; then
		sudofail=chown
		exit $FAILURE
	fi
fi

# Make sure only one person is building zone files at a time
if [ "$editmode" ] || [ "$sync" ]; then
	getlock
	predit
fi

# Display zone menu unless -a/-l given
[ "$updzones" ] || zonemenu

#
# If there are changes to the master files, generate the zones
#
[ "$updzones" ] || exit $SUCCESS
if [ "$sync" ]; then
	msg "File generation called by sync option."
	msg "Files: $updzones"
else
	# We need a description of why this is being done
	( set -e
		tmpfile=$( mktemp -t "$pgm.XXXXXXXX" )
		awk 'sub(/^\t+/,"")||1' >> "$tmpfile" <<-EOF


		# Please enter some text describing your changes
		#
		# IMPORTANT! Lines beginning with # are ignored
		# IMPORTANT! Blank lines are ignored
		#
		# WARNING! Changes will be aborted without a message
		EOF
		trap 'rm -f "$tmpfile" > /dev/null 2>&1' EXIT
		${EDITOR:-vi} "$tmpfile"
		msg=$( awk '!/^[[:space:]]*(#|$)/' "$tmpfile" )
		cat "$log" > "$tmpfile"
		if [ ! "$msg" ]; then
			msg="WARNING! No message entered. Cancelling."
			echo "$msg" >&2
			echo "$msg" > "$log"
			echo >> "$log"
			cat "$tmpfile" >> "$log"
			exit $FAILURE
		fi
		echo "$msg" > "$log"
		echo >> "$log"
		cat "$tmpfile" >> "$log"
	) || exit
fi
genmaster
pushzones
dnsreload

exit $SUCCESS

################################################################################
# END
################################################################################
