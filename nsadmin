#!/bin/sh
#-
# Copyright (c) 2006-2013 Parker Lee Ranney TTEE
# Copyright (c) 2017-2019 Devin Teske <dteske@FreeBSD.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
############################################################ IDENT(1)
#
# $Title: Distributed bind9 administration and management tool $
# $Id: nsadmin,v 1.1 2012/05/09 21:39:43 root Exp $
# $Copyright: 2017-2019 Devin Teske. All rights reserved. $
# $FrauBSD: nsadmin/nsadmin 2019-10-30 08:29:17 -0700 freebsdfrau $
#
############################################################ INFORMATION
#
# nsadmin -- Update Bind's installation on the master NS server. RCS
# 	is used for file history. All updates will be sent out as an
# 	email to the appropriate admin address. A lock is kept during
# 	the run of this program to prevent conflicting updates.
#
# --------------------------------------------------------------------
# Notes:
# 	- Requires bind server and nsadmin.conf on the master.
# 	- Requires nsslave and nsslave-var.inc on the slave Bind
# 	  servers to operate.
# 	- User 'cm' and the authorized_keys2 file for that user must
# 	  be installed on all slave Bind servers. The 'cm' user account
# 	  and ID file must be on the server with this script.
# 	- User 'cm' must be able to remotely execute via SSH the
# 	  following command:
# 		sudo /usr/local/bin/nsslave
# 	  Without password on the slave Bind servers.
# 	- Users must be placed in the DNSOPS group in sudoers as a
# 	  result of the commands that require root access.
# 	  Commands used via sudo: awk chmod chown cp find mv rm service su
# 	- Users must also belong to the "bind" group in /etc/group to
# 	  edit the files.
# --------------------------------------------------------------------
# Version History:
# 	Oct 2019: Release 4.9.9
# 		- Show all pending diffs with `/diff' in edit mode
# 		- Improve pause() and change ENTER to return
# 		- Use pause() in place of peppered recipes to wait
# 		- Make a read that is ignored more visibly-so
# 		- Revert changed state if edit undoes a change
# 	Oct 2019: Release 4.9.8
# 		- Do not use sudo in sigquit()
# 		- Revert some previous changes around locking
# 	Oct 2019: Release 4.9.7
# 		- Add /diff command
# 		- Centralize definition of view/edit commands
# 	Oct 2019: Release 4.9.6
# 		- Whitespace
# 		- Trim leading blank lines from /log output
# 	Oct 2019: Release 4.9.5
# 		- Hide zone history unless in edit mode
# 		- Add /log command
# 		- Enable commands in view mode (/log only)
# 	Oct 2019: Release 4.9.4
# 		- Improve handling of commit message
# 		- Add user-provided commit message to checkin()
# 		- Optimize genconf() for performance
# 	Oct 2019: Release 4.9.3
# 		- Add /mv command
# 		- Make globals all-caps
# 		- Remove signal management variable (ransig)
# 		- Remove unused variable (vfail)
# 		- Improve security around /-command execution
# 		- Display deleted zones in menu, greyed-out
# 		- Add details on edit how to resurrect removed zones
# 	Oct 2019: Release 4.9.2
# 		- Revert reset of traps before generation tasks
# 		- Whitespace
# 		- Remove stray semi-colon
# 	Oct 2019: Release 4.9.1
# 		- Fix editmaster() read-only issue on re-edits
# 		- Fix unnecessary compound string in sigquit()
# 		- Re-checkout /rm'd zones on unclean exit
# 		- Remove /new'd zones on unclean exit
# 		- Make /rm require config regeneration and edit desc
# 		- Add `-u' and `-v' command-line options to checkout()
# 		- Use checkout() in newzone() instead of one-off `co'
# 		- Ensure /rm'd zones/revs are not resolvable after rm
# 		- Prevent `/' commands in view mode
# 		- Improve vimcat handling
# 		- Warn user when journal file exists
# 		- Move `local' definitions in rmzone() to top of function
# 		- Always forcefully lock files before ci in checkin()
# 		- Highlight rm'd zones as-such (red) during backups
# 		- Print config file paths during genconf()
# 		- Reset traps before entering generation stage
# 	Oct 2019: Release 4.9
# 		- Move vim filetype hint to top of new zone template
# 		- Move command-line option global definitions
# 		- Fix `-n slave[,...]' config override
# 		- Show diff when importing changes detected during sync
# 	Oct 2019: Release 4.8.9
# 		- If running as root, require new `-u user' option
# 		- Check user after sourcing config so we can write to log
# 		- Fail immediately if log variable not set in config
# 		- Use green banner in edit mode, red when unsaved changes
# 	Oct 2019: Release 4.8.8
# 		- Ignore jnl files created by nsupdate in conf generation
# 	Oct 2019: Release 4.8.7
# 		- Add support for @ in zone2rev()
# 	Oct 2019: Release 4.8.6
# 		- Final fixup for /new RCS checkout
# 		- Improve backup efficiency
# 		- Skip checkin if no differences
# 		- Create new files with template contents
# 	Oct 2019: Release 4.8.5
# 		- Show files being backed up
# 		- Fixup /new RCS checkout
# 	Oct 2019: Release 4.8.4
# 		- User interface/log enhancement
# 	Oct 2019: Release 4.8.3
# 		- Fixup user interface and log nits
# 	Oct 2019: Release 4.8.2
# 		- Fixup creation of new/existing zone via /new
# 	Oct 2019: Release 4.8.1
# 		- Fixup RCS checkout by /new
# 	Oct 2019: Release 4.8
# 		- Make /new check for RCS files
# 	Oct 2019: Release 4.7.7
# 		- Add support for sender domain override
# 	Oct 2019: Release 4.7.6
# 		- Fix ANSI clear codes
# 	Oct 2019: Release 4.7.5
# 		- Fix ANSI escape sequences for BSD
# 	Oct 2019: Release 4.7.4
# 		- Remove log of sudo failure
# 	Oct 2019: Release 4.7.3
# 		- Fix detection of sudo failure in predit()
# 	Oct 2019: Release 4.7.2
# 		- Wordsmithing
# 	Oct 2019: Release 4.7.1
# 		- Fix version
# 		- Change header color when changes made
# 	Oct 2019: Release 4.7
# 		- Add /new and /rm commands to edit prompt
# 	Oct 2019: Release 4.6.5
# 		- Fix TLD record generation
# 	Oct 2019: Release 4.6.4
# 		- Fix error in genconf() when no rev maps exist
# 	Oct 2019: Release 4.6.3
# 		- Fix copy/pasta
# 	Oct 2019: Release 4.6.2
# 		- Minor edit
# 	Oct 2019: Release 4.6.1
# 		- Use sudo to create view directories
# 	Oct 2019: Release 4.6
# 		- Add support for TLD A/AAAA records
# 		- Create $nsadmindir on initial launch
# 	Oct 2019: Release 4.5.9
# 		- Use full paths in genconf()
# 	Oct 2019: Release 4.5.8
# 		- Fix configuration defaults
# 	Oct 2019: Release 4.5.7
# 		- Make mail optional with disabled defaults
# 	Oct 2019: Release 4.5.6
# 		- Make default slaves empty in config
# 	Oct 2019: Release 4.5.5
# 		- Use BSD compatible ANSI escape sequences for printf
# 	Oct 2019: Release 4.5.4
# 		- Fix config
# 	Oct 2019: Release 4.5.3
# 		- Add OS Glue to config for FreeBSD
# 	Oct 2019: Release 4.5.2
# 		- Defer loading of config until after processing options
# 		- Defer check for root until after options processing
# 		- Comments
# 		- Look for config in proper directory based on OS
# 	Oct 2019: Release 4.5.1
# 		- Remove confusing line numbers from named-checkzone output
# 		- Comments and other Minor edits
# 		- Fix version
# 	Oct 2019: Release 4.5
# 		- Make include files for generated zones and rev maps
# 	Oct 2019: Release 4.4.1
# 		- Remove log if exiting due to running as root
# 	Oct 2019: Release 4.4
# 		- Show lock file location when locked
# 		- Do not use sudo in sigquit() if first use fails
# 		- Release lock if exiting due to sudo failure
# 	Oct 2019: Release 4.3
# 		- Fix sync (-s) based checkin from automated edits
# 	Oct 2019: Release 4.2.2
# 		- Add support for vimcat in read-only view mode
# 		- Improve vimcat support with PAGER in all modes
# 	Oct 2019: Release 4.2.1
# 		- Show progress as we generate rev maps
# 		- Only checkin sync'd files on exit if they pass syntax check
# 		- Fix memory leak in genrev()
# 		- Minimally improve and document sudo support
# 	Oct 2019: Release 4.2
# 		- checkin files after sync (-s)
# 	Oct 2019: Release 4.1.1
# 		- Lower sync verbosity
# 	Oct 2019: Release 4.1
# 		- Add support for inline custom TTL preceding protocol family
# 	Oct 2019: Release 4.0.4
# 		- Do not show contextual diff before review
# 		- Add whitespace after main menu prompt
# 	Oct 2019: Release 4.0.3
# 		- Fix rev map synchronization with `-s'
# 		- Trim trailing whitespace on code lines
# 		- Fix spurious error from `cd -' in sigquit()
# 	Oct 2019: Release 4.0.2
# 		- Fix permission issues for members of $bindgroup
# 	Oct 2019: Release 4.0.1
# 		- Fix hang on stdin from RCS co when file is writable
# 	Oct 2019: Release 4.0
# 		- Replace bash arrays with POSIX /bin/sh syntax
# 		- Do not overwrite config files if they exist on install
# 		- Change umask to 0022
# 		- Remove obsolete code
# 		- Improve check for duplicate running instances
# 		- Create required directories if they do not exist
# 		- Optimize usage of "cd" to fix errors
# 		- Improved debugging
# 		- Renamed *-var.inc to *.conf and cleanup
# 		- Merge *.inc files and zone2rev.awk into nsadmin
# 		- Set default view [required] to program basename (nsadmin)
# 		- Add support for `IN' protocol family in master zones
# 		- Fix `-l' to work with `-s'
# 		- Prevent Outlook from eating blank lines in diffs
# 		- Merge nsslave-centos7 into nsslave
# 		- Add support for vimcat
# 		- Add limited ANSI coloring to console output
# 		- Add support for `less -F' when viewing diffs
# 		- Add `-v' to get version
# 	Aug 2019: Release 3.2
# 		- Add Makefile
# 	Jul 2019: Release 3.1
# 		- Initial Public release.
# 		- Enable restriction to prevent anonymous root access.
# 		- Add secondary variable to `nsadmin-var.inc'.
# 		- Fix hard-coded primary/secondary in `GEN FUNCTIONS'.
# 	Jul 2018: Release 3.0
# 		- Major rewrite and code cleanup.
# 		- Improved error checking of zone files.
# 		- Support IPv6 AAAA records.
# 	Jul 2018: Release 2.6
# 		- Fix bug preventing some reverse entries from being created
# 	Jul 2018: Release 2.5
# 		- Fix bug preventing reverse lookup of A records ending in
# 		  .0 or .255
# 	Jul 2017: Release 2.4
# 		- Ask the user for a message to describe changes.
# 		- Only allow one instance of nsadmin at a time.
# 	Jun 2017: Release 2.3
# 		- Add `-n slaves' syntax for selecting a subset of slaves.
# 		- Ported to FreeBSD.
# 	Mar 2010: Release 2.2
# 		- Fixed comments.
# 	Jul 2006: Release 2.1
# 		- Modified to migrate zones manually as IXFR and AXFR
# 		  are not reliable.
# 	Jun 2006: Release 2.0
# 		- Major rewrite and creation of includes.
# 		- Syntax checking.
# 		- Update only the rev maps with a changed IP.
# 		- Added read-only interface.
# 		- Added ability to generate zone files and rev maps
# 		  from the master files without performing updates,
# 		  known as sync.
# 	Apr 2006: Release 1.0
# 		- Basic interface and zone generation.
#
############################################################ INCLUDES

NSADMIN_CONF=nsadmin.conf # See OS Glue

############################################################ GLOBALS

VERSION='$Version: 4.9.9 $'

pgm="${0##*/}" # Program basename
progdir="${0%/*}" # Program directory

PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

#
# Global exit status
#
SUCCESS=0
FAILURE=1

#
# Command-line options
#
USER=		# -u user
EDITMODE=	# -e
SYNC=		# -s
SYNCALL=	# -a
UPDZONES=	# -l file[,...] (also used to track edited zones)
SLAVES=		# -n slave[,...] (taken from $NSADMIN_CONF if unused or NULL)

#
# Commands
#
EDITCMDS="/diff /log /mv /new /rm"
VIEWCMDS="/diff /log"

#
# OS Glue
#
: ${UNAME_s:=$( uname -s )}

#
# Miscellaneous
#
COMMITMSG=				# User-provided commit message
CHANGES=				# Have changes been made?
FAILFILE=				# File that failed zonetest()
FAILTYPE=				# Type of file that failed
MVJNL=					# Move journal for commit
MVJNLREV=				# Reverse move journal for interrupt
NEWZONES=				# Newly created zones
RMDREVS=				# Rev maps of removed zones
RMDZONES=				# Removed zones
ROOTFAIL=				# Exited due to running as root
SEP=$( printf %75s | tr " " - )		# Separator
SEPDBL=$( printf %20s | tr " " = )	# Double separator
SUBNETS=				# Subnets changed for rev maps
SYNCCNT=0				# Number of files sync'd
UPDATE=					# Stage of master file updates

############################################################ FUNCTIONS

have(){ type "$@" > /dev/null 2>&1; }

# usage
#
# Print the help menu and exit.
#
usage()
{
	exec >&2
	echo
	echo "  Usage: $pgm ..."
	echo
	echo "    Edit Mode:"
	echo "	Used to edit the master $pgm files:"
	echo
	echo "		$pgm [-n slaves] -e"
	echo
	echo "    Review Mode: (Default)"
	echo "	Used to view the master $pgm files:"
	echo
	echo "		$pgm"
	echo
	echo "    Sync Mode:"
	echo "	Used to update the Bind zone files with the data from"
	echo "	the master $pgm files. This does not allow"
	echo "	editing of the master files:"
	echo
	echo "		$pgm -s [-ah?] [-n slaves] -l <file>[,<file>, ..."
	echo
	echo "		-a			Sync all master files."
	echo "		-l <file>[,<file>]	Sync list of files."
	echo "		-n <slave>[,<slave>]	Override list of slaves."
	echo

	exit $FAILURE
}

############################################################ REV FUNCTIONS
# Functions for generating rev maps from master zones

# zone2rev [-cdilv] $file
#
# Read nsadmin zone $file and produce rev map.
#
# Options:
# 	-c          Enable ANSI color. Implies `-d'
# 	-d          Enable debug messages printed to stderr
# 	-i          Initialize files to zero length
# 	-l          List subnets on stdout and exit
# 	-r          List reverse arpa subnets on stdout and exit
# 	-S          Use sudo
# 	-s subnet   Process only subnet from $file
# 	-V          Verify contents and exit. Implies `-d'
# 	-v view     Process only view from $file
#
exec 9<<'EOF'
function err(str)
{
	if (verify) vstatus = 1
	if (!debug) return
	if (console)
		printf "\033[35m%s\033[36m:\033[32m%d\033[36m:\033[m %s\n",
			file, NR, str > "/dev/stderr"
	else
		printf "%s:%d: %s\n", file, NR, str > "/dev/stderr"
	fflush()
}

# _asorti(src, dest)
#
# Like GNU awk's asorti() but works with any awk(1)
# NB: Named _asorti() to prevent conflict with GNU awk
#
function _asorti(src, dest,        k, nitems, i, idx)
{
	k = nitems = 0
	for (i in src) dest[++nitems] = i
	for (i = 1; i <= nitems; k = i++) {
		idx = dest[i]
		while ((k > 0) && (dest[k] > idx)) {
			dest[k+1] = dest[k]; k--
		}
		dest[k+1] = idx
	}
	return nitems
}

# validate_ipaddr4(ip)
#
# Returns zero if the given argument (an IP address) is of the proper format.
#
# The return value for invalid IP address is one of:
# 	1	One or more individual octets within the IP address (separated
# 		by dots) contains one or more invalid characters.
# 	2	One or more individual octets within the IP address are null
# 		and/or missing.
# 	3	One or more individual octets within the IP address exceeds the
# 		maximum of 255 (or 2^8-1, being an octet comprised of 8 bits).
# 	4	The IP address has either too few or too many octets.
#
function validate_ipaddr4(ip,        octets, noctets, n, octet)
{
	# Split on `dot'
	noctets = split(ip, octets, /\./)
	if (noctets != 4) return 4

	for (n = 1; n <= noctets; n++) {
		octet = octets[n]

		# Return error if the octet is null
		if (octet == "") return 2

		# Return error if not a whole/positive integer
		if (octet ~ /[^0-9]/) return 1

		# Return error if the octet exceeds 255
		if (octet > 255) return 3
	}

	return 0
}

# validate_ipaddr6(ip)
#
# Returns zero if the given argument (an IPv6 address) is of the proper format.
#
# The return value for invalid IP address is one of:
# 	1	One or more individual segments with the IP address
# 		(separated by colons) contains one or more invalid characters.
# 		Segments must contain only combinations of the characters 0-9,
# 		A-F, or a-f.
# 	2	Too many/incorrent null segments. A single null segment is
# 		allowed within the IP address (separated by colons) but not
# 		allowed at the beginning or end (unless a double-null segment;
# 		i.e., "::*" or "*::").
# 	3	One or more individual segments within the IP address
# 		(separated by colons) exceeds the length of 4 hex-digits.
# 	4	The IP address entered has either too few (less than 3), too
# 		many (more than 8), or not enough segments, separated by
# 		colons.
# 	5	The IPv4 address at the end of the IPv6 address is invalid.
#
function validate_ipaddr6(ip,
	segments, nsegments, n, segment, h, short, nulls,
	contains_ipv4_segment, maxsegments)
{
	sub(/%.*$/, "", ip) # remove interface spec if-present

	# Split on `colon'
	nsegments = split(ip, segments, /:/)

	# Return error if too many or too few segments
	# Using 9 as max in case of leading or trailing null spanner
	if (nsegments > 9 || nsegments < 3) return 4

	h = "[0-9A-Fa-f]"
	short = sprintf("^(%s|%s|%s|%s)$", h, h h, h h h, h h h h)

	nulls = contains_ipv4_segment = 0

	for (n = 1; n <= nsegments; n++) {
		segment = segments[n]

		#
		# Return error if this segment makes one null too-many. A
		# single null segment is allowed anywhere in the middle as well
		# as double null segments are allowed at the beginning or end
		# (but not both).
		#
		if (segment == "") {
			nulls++
			if (nulls == 3) {
				# Only valid syntax for 3 nulls is `::'
				if (ip != "::") return 2
			} else if (nulls == 2) {
				# Only valid if begins/ends with `::'
				if (ip !~ /(^::|::$)/) return 2
			}
			continue
		}

		#
		# Return error if not a valid hexadecimal short
		#
		if (segment ~ short) continue # Valid segment of 1-4 hex digits
		if (segment ~ /[^0-9A-Fa-f]/) {
			# Segment contains at least one invalid char

			# Return error immediately if not last segment
			if (n < nsegments) return 1

			# Otherwise, check for legacy IPv4 notation
			if (segment ~ /[^0-9.]/) {
				# Segment contains at least one invalid
				# character even for an IPv4 address
				return 1
			}

			# Return error if not enough segments
			if (nulls == 0) {
				if (nsegments != 7) return 4
			}

			contains_ipv4_segment=1

			# Validate ipv4_segment
			if (validate_ipaddr4(segment)) return 5
		} else {
			# Segment characters are all valid but too many
			return 3
		}
	}

	if (nulls == 1) {
		# Single null segment cannot be at beginning/end
		if (ip ~ /(^:|:$)/) return 2
	}

	#
	# A legacy IPv4 address can span the last two 16-bit segments,
	# reducing the amount of maximum allowable segments by-one.
	#
	maxsegments = contains_ipv4_segment ? 7 : 8

	if (nulls == 0) {
		# Return error if missing segments with no null spanner
		if (nsegments != maxsegments) return 4
	} else if (nulls == 1) {
		# Return error if null spanner with too many segments
		if (nsegments > maxsegments) return 4
	} else if (nulls == 2) {
		# Return error if leading/trailing `::' with too many segments
		if (nsegments > (maxsegments + 1)) return 4
	}

	return 0
}

# split6(ip, array)
#
# Split the elements of IPv6 ip into 32 hex-nibbles stored in array.
#
function split6(ip, nibbles,        n, ip4, octs, s, i, nibs, nib, k)
{
	for (n = 1; n <= 32; n++) nibbles[n] = 0
	if (match(ip, /:[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/)) {
		ip4 = substr(ip, RSTART + 1)
		ip = substr(ip, 1, RSTART - 1)
		split(ip4, octs, /\./)
		ip = sprintf("%s:%02x%02x:%02x%02x",
			ip, octs[1], octs[2], octs[3], octs[4])
	}
	if (sub(/^::/, "", ip)) {
		n = 32
		ip = sprintf("%04s", ip)
		for (k = 4; k > 0; k--) nibbles[n--] = substr(ip, k, 1)
	} else if (sub(/::$/, "", ip)) {
		n = 1
		ip = sprintf("%04s", ip)
		for (k = 1; k <= 4; k++) nibbles[n++] = substr(ip, k, 1)
	} else if (ip ~ /::/) {
		left = right = ip
		sub(/::.*$/, "", left)
		sub(/^.*::/, "", right)
		s = split(left, nibs, /:/)
		for (i = 1; i <= s; i++) {
			n = (i - 1) * 4 + 1
			nib = sprintf("%04s", nibs[i])
			for (k = 1; k <= 4; k++)
				nibbles[n++] = substr(nib, k, 1)
		}
		s = split(right, nibs, /:/)
		n = 32
		for (i = s; i > 0; i--) {
			nib = sprintf("%04s", nibs[i])
			for (k = 4; k > 0; k--)
				nibbles[n--] = substr(nib, k, 1)
		}
	} else {
		s = split(ip, nibs, /:/)
		for (i = 1; i <= s; i++) {
			n = (i - 1) * 4 + 1
			nib = sprintf("%04s", nibs[i])
			for (k = 1; k <= 4; k++)
				nibbles[n++] = substr(nib, k, 1)
		}
	}
}

BEGIN {
	if (console || verify) debug = 1
	if (list_reverse) list_subnets = 1
	vstatus = 0

	subnet = tolower(subnet)
	delete initialized
	delete files
	NR = 0
	rec = ""
	while (getline < file > 0) {
		NR++
		if (/^[[:space:]]*;/) continue
		if ($1 ~ "^" file) continue
		if (/;*VIEW:/ && $0 !~ view) continue
		if (/\*/) continue
		gsub(/;.*/, "")
		delete U
		for (n = 1; n <= 5 && n <= NF; n++) U[n] = toupper($n)
		if (NF == 2) {
			type = U[1]
			ip = $2
		} else if (NF == 3) {
			if ($1 !~ /^([0-9]+|IN)$/) rec = $1
			type = U[2]
			ip = $3
		} else if (NF == 4 && U[2] ~ /^([0-9]+|IN)$/) {
			if ($1 !~ /^[0-9]+$/) rec = $1
			type = U[3]
			ip = $4
		} else if (NF == 5 && $2 ~ /^[0-9]+$/ && U[3] == "IN") {
			rec = $1
			type = U[4]
			ip = $5
		} else {
			continue
		}
		if (type == "A") {
			if ((errno = validate_ipaddr4(ip)) != 0) {
				err(sprintf("bad A record `%s' for `%s' " \
					"(ERR#%u)", ip, rec, errno))
				continue
			}
			split(ip, oct, /\./)
			net = sprintf("%u.%u.%u", oct[1], oct[2], oct[3])
			if (!list_subnets && subnet && net != subnet) continue
			rev = sprintf("%u.%u.%u", oct[3], oct[2], oct[1])
			ptr = sprintf("%u\t\t\t\t\tPTR\t%s%s%s.",
				oct[4], rec == "@" ? "" : rec,
				rec ~ /^@?$/ ? "" : ".", file)
		} else if (type == "AAAA") {
			if ((errno = validate_ipaddr6(ip)) != 0) {
				err(sprintf("bad AAAA record `%s' for `%s' " \
					"(ERR#%u)", ip, rec, errno))
				continue
			}
			delete nib
			split6(ip, nib)
			net = sprintf("%s%s%s%s:%s%s%s%s:%s%s%s%s:%s%s%s%s",
				nib[1], nib[2], nib[3], nib[4],
				nib[5], nib[6], nib[7], nib[8],
				nib[9], nib[10], nib[11], nib[12],
				nib[13], nib[14], nib[15], nib[16])
			if (!list_subnets && subnet && tolower(net) != subnet)
				continue
			rev = tolower(sprintf( \
				"%s.%s.%s.%s." \
				"%s.%s.%s.%s." \
				"%s.%s.%s.%s." \
				"%s.%s.%s.%s",
				nib[16], nib[15], nib[14], nib[13],
				nib[12], nib[11], nib[10], nib[9],
				nib[8], nib[7], nib[6], nib[5],
				nib[4], nib[3], nib[2], nib[1]))
			ptr = sprintf( \
				"%s.%s.%s.%s." \
				"%s.%s.%s.%s." \
				"%s.%s.%s.%s." \
				"%s.%s.%s.%s" \
				"\t\tPTR\t%s%s%s.",
				nib[32], nib[31], nib[30], nib[29],
				nib[28], nib[27], nib[26], nib[25],
				nib[24], nib[23], nib[22], nib[21],
				nib[20], nib[19], nib[18], nib[17],
				rec == "@" ? "" : rec,
				rec ~ /^@?$/ ? "" : ".", file)
		} else {
			continue
		}
		if (list_subnets || list_reverse) {
			if (list_reverse)
				subnets[rev] = 1
			else
				subnets[net] = 1
			continue
		}
		rev = ".new-" rev
		if (initialize && !(rev in initialized)) {
			printf "" > rev
			initialized[rev] = 1
		}
		files[rev] = 1
		print ptr >> rev
	}
	exit
}

END {
	if (verify) exit vstatus
	if (list_subnets) {
		n = _asorti(subnets, subnets_sorted)
		for (i = 1; i <= n; i++) print subnets_sorted[i]
		exit
	}

	if (!debug) exit
	fmt = console ? "\033[32m%5d\033[36m:\033[m %s\n" : "%5d: %s\n"
	n = _asorti(files, files_sorted)
	for (i = 1; i <= n; i++) {
		rev = files_sorted[i]
		if (console)
			printf "\033[32m>\033[m %s\n", rev > "/dev/stderr"
		else
			printf "> %s\n", rev > "/dev/stderr"
		while (getline < rev > 0)
			printf fmt, ++NRr[rev], $0 > "/dev/stderr"
	}
}
EOF
zone2rev_awk=$( cat <&9 )
zone2rev()
{
	local console=0
	local debug=0
	local initialize=0
	local list_reverse=0
	local list_subnets=0
	local subnet=
	local sudo=
	local verify=0
	local view=
	local OPTIND=1 OPTARG flag

	while getopts cdilrSs:Vv: flag; do
		case "$flag" in
		c) console=1 ;;
		d) debug=1 ;;
		i) initialize=1 ;;
		l) list_subnets=1 ;;
		r) list_reverse=1 ;;
		S) sudo=1 ;;
		s) subnet="$OPTARG" ;;
		V) verify=1 ;;
		v) view="$OPTARG" ;;
		esac
	done
	shift $(( $OPTIND - 1 ))

	${sudo:+sudo} awk -v console=$console \
		-v debug=$debug \
		-v file="$1" \
		-v initialize=$initialize \
		-v list_reverse=$list_reverse \
		-v list_subnets=$list_subnets \
		-v subnet="$subnet" \
		-v verify=$verify \
		-v view="$view" \
		"$zone2rev_awk"
}

############################################################ EDIT FUNCTIONS
# Functions to edit/change master files for zone and rev maps

# editmaster zone
#
# Edit the master files.
#
editmaster()
{
	local file="$1"

	log -d "Editing $file"

	cd "$nsadmindir"
	checkout "$file"

	chmod ug+w "$file"
	${EDITOR:-vi} "$file"
	verify "$file"

	cd - > /dev/null
}

# getlock
#
# Establish an exclusive lock for master file edits.
#
getlock()
{
	local clobber=
	local res

	if [ -f "$lock" ]; then
		res=$( ls -l "$lock" | awk '{print $3}' )
		printf "\033[2mlock: %s\033[m\n" "$lock"
		fatal "lock file exists, owner is $res" # NOTREACHED
	fi

	[ "$-" = "${-#*C}" ] && clobber=1
	set -C
	echo $$ > "$lock" || fatal "could not create '$lock'" # NOTREACHED
	[ "$clobber" ] && set +C
}

# predit
#
# Prepare the editing of the master files.
#
predit()
{
	local dir

	trap sigquit EXIT

	msg "$USER starting edits: $( date )"

	sudo rm -rf "$log" "$tmp" .bak-* .revunq .updzones .view* ||
		exit $FAILURE

	trap "sigquit; exit" SIGHUP SIGINT SIGQUIT SIGTERM

	echo > "$log"
	log " Starting: $( date )"

	mkdir -p -m 0770 "$tmp"

	# Make tmp directory owned by BIND user/group and group-writable
	dir="$tmp"
	case "$dir" in
	*/) dir="${dir%/}" ;;
	esac
	dir="${dir%/*}"
	case "$dir" in
	/) : skip ;;
	*) sudo chown -R "$binduser:$bindgroup" "$dir"
	   sudo chmod -R g+w "$dir"
	esac
}

# clear
#
# Like clear(1) but preserve scrollback.
#
clear()
{
	local size rows cols
	size=$( stty size 2> /dev/null )
	set -- ${size:-24 80}
	rows="$1"
	cols="$2"
	printf "\033[${rows}S\033[H\033[J"
}

############################################################ GEN FUNCTIONS
# Functions to generate zone files and reverse maps

# genmaster
#
# Generate the zone files and rev maps.
#
genmaster()
{
	local file
	local ignored
	local subnet

	#
	# Save the master files that have changes to make sure they
	# are not lost in the loop'ing below.
	#
	echo "$UPDZONES" > "$nsadmindir/.updzones"

	#
	# Generate a list of all subnets in the master file
	#
	if [ "$SYNC" -o "$MVJNL" ]; then
		for subnet in $(
			for file in $UPDZONES; do
				zone2rev -l "$file"
			done | sort -u
		); do
			# Only insert subnet if not existing in $SUBNETS
			echo "$SUBNETS" | grep -q "\\<$(
				echo "$subnet" | sed -e 's/\./\\&/g'
			)$subnet\\>" || SUBNETS="$SUBNETS $subnet"
		done
		SUBNETS="${SUBNETS# }"
	fi

	#
	# Loop through the zone file generation until each error is
	# fixed. Slave systems will not sync bad zone files nor will
	# the master load them.
	#
	while :; do
		echo
		msg "Building zone files and revmaps: $( date )"
		genzone $( cat "$nsadmindir/.updzones" )
		genrev

		zonetest
		[ "$FAILFILE" ] || break

		printf "\n\033[1mPress return when ready to re-edit.\033[m"
		stty -echo
		read ignored
		stty echo

		# Clean up the previous attempt
		find "$tmp" -type f -exec rm -f {} \;

		#
		# XXX Use the rcsdiff output to find the correct
		# XXX zone to edit instead of relying on the user to
		# XXX remember which file had errors.
		#
		if [ "$FAILTYPE" = rev ]; then
			zonemenu
		else
			editmaster "$FAILFILE"
		fi
	done
}

# genrev
#
# Generate the reverse maps.
#
genrev()
{
	local excl
	local file
	local list
	local n
	local origin
	local rev
	local revfile
	local subnet
	local t
	local view
	local zone2rev_debug

	cd "$nsadmindir"
	for view in $views; do
		msg " VIEW: $view/rev"

		# Truncate subnets belonging to removed zones
		for n in $RMDREVS; do :> ".new-$n"; done

		list="${UPDZONES:-$( ls -d [a-z0-9]* )}"
		for excl in $exclude; do
			list=$( echo "$list" | sed -e "s/$excl//" )
		done

		n=1
		t=$( set -- $list; echo $# )
		zone2rev_debug=
#?		[ "$SYNC" ] && zone2rev_debug=-d # Testing -- Devin
		for file in $list; do
			printf "  \033[2m%-30s \033[1m%4u/%-4u\033[m\n" \
				"[$file]" $n $t
			for subnet in $SUBNETS; do
#?				printf "  \033[3m-> $subnet\033[m\n"
#?					# Testing -- Devin
				zone2rev -S $zone2rev_debug \
					-v "$view" -s "$subnet" "$file"
			done
#?			echo # Testing -- Devin
			n=$(( $n + 1 ))
		done
		echo

		for file in .new-*; do
			[ -e "$file" ] || continue

			revfile=$( echo "$file" | sed -e "s/^.new-//" )
			case "$revfile" in
			*.*.*.*.*) origin="$revfile.ip6.arpa." ;;
			*) origin="$revfile.in-addr.arpa." ;;
			esac
			rev="$tmp/$view/rev/$revfile"

			revunq "$file"

			awk 'sub(/^\\t/,"\t")||1' > "$rev" <<-EOF
			\$TTL $ttl
			@ IN SOA $primary. $contact. (
			\t		$serial	; serial
			\t		$refresh		; refresh
			\t		$retry		; retry
			\t		$expire		; expire
			\t		$minimum )		; minimum
			\t		IN NS $primary.
			\t		IN NS $secondary.
			\$ORIGIN $origin
			EOF
			grep -v ";" "$file" >> "$rev"

			rm -f "$file"
		done
	done
	cd - > /dev/null
}

# colorize [file ...]
#
# Print file contents (or stdin) colorized. Requires vimcat.
#
colorize()
{
	if have vimcat; then
		vimcat "$@" | awk 'NR==1{next}gsub(/\r/,"")||1'
	else
		cat "$@"
	fi
}

# genzone zone ...
#
# Generate the master zone files.
#
genzone()
{
	local diff=
	local file
	local list="$*" # edited zones
	local origin
	local view

	for view in $views; do
		mkdir -p -m 0770 "$tmp/$view/master" "$tmp/$view/rev"
	done

	for view in $views; do
		msg " VIEW: $view/master"
		cd "$tmp/$view/master"

		for file in $list; do
			printf "  \033[2m-> $file\033[m\n"
			origin="$file."

			awk 'sub(/^\\t/,"\t")||1' > "$file" <<-EOF
			\$TTL $ttl
			@ IN SOA $primary. $contact. (
			\t		$serial	; serial
			\t		$refresh		; refresh
			\t		$retry		; retry
			\t		$expire		; expire
			\t		$minimum )		; minimum
			\t		IN NS $primary.
			\t		IN NS $secondary.
			\$ORIGIN $origin
			EOF

			#
			# Keep any semicolons within a quoted TXT
			# record. Clear away all others.
			#
			awk -v view="$view" '
			!/^[[:space:]]*(;|$)/ {
				if (/;*VIEW:/ && $0 !~ view) next
				if (/".*;.*"/)
					sub(/; VIEW:.*/, "")
				else
					sub(/;.*/, "")
				print
			}' "$nsadmindir/$file" >> "$file"

			#
			# Generate diff in sync mode if there are changes
			#
			if [ "$SYNC" ]; then
				diff=$( cd "$nsadmindir" &&
					rcsdiff -u "$file" 2> /dev/null )
			fi
			if [ "$diff" ]; then
				echo "$diff" | awk '$0="   "$0' >> "$log"
				echo "$diff" | colorize | awk '$0="     "$0'
			fi
		done

		cd - > /dev/null
	done

	sudo chown -R "$binduser:$bindgroup" "$tmp/$view"
	sudo chmod -R g+w "$tmp/$view"
}

# revunq file
#
# Generate a rev map file with unique PTR records based on resulting hostname
# pointers.
#
revunq()
{
	local file="$1"

	awk -v file="$file" '
	function posnum(str)
	{
		if (str ~ /ns[0-9]*\.example\.com/) return 6
		if (str ~ /mx[0-9]*\.googlemail\.com/) return 6
		if (str ~ /\..*\.example\.com/) return 5
		if (str ~ /\.example\.com/) return 4
		if (str ~ /\.example\./) return 3
		return 1
	}
	BEGIN {
		delete host
		while (getline < file > 0) {
			if (!($1 in host)) host[$1] = $3
			else if (posnum(host[$1]) < posnum($3)) host[$1] = $3
		}
		for (unit in host) printf("%s%s\t\tPTR\t%s\n",
			unit, length(unit) <= 3 ? "\t\t\t" : "", host[unit])
	}
	' > .revunq

	sudo mv .revunq "$file"
}

# genconf view ...
#
# Make BIND include files of generated zones and rev maps for each given view.
#
genconf()
{
	local view zone
	local prefix='^[[:space:]]*$ORIGIN\>.*'
	local suffix='\.arpa\.\([[:space:]]\|$\)'
	local ip4arpa="$prefix"'\.in-addr'"$suffix"
	local ip6arpa="$prefix"'\.ip6'"$suffix"

	cd "$nameddir" || return
	for view in "$@"; do
		mkdir -p -m 0770 "$view/include"
		sudo chown "$binduser:$bindgroup" "$view/include"

		# Generate master.conf include for view
		{ for file in "$nameddir/$view"/master/*; do
			[ -e "$file" ] || continue
#?			printf "\t  \033[2m-> %s\033[m\n" \
#?				"$file" >&2 # Testing -- Devin
			case "$file" in
			*.jnl) continue ;;
			esac
			zone="${file##*/}"
			printf 'zone "%s" in {\n' "$zone"
			printf '\ttype master;\n'
			printf '\tfile "%s";\n' "$file"
			printf '\tnotify yes;\n'
			printf '};\n'
		done; } | sudo tee "$view/include/master.conf" > /dev/null

		# Generate rev.conf include for view
		{ for file in "$nameddir/$view"/rev/*; do
			[ -e "$file" ] || continue
			filename="${file##*/}"
			for x in $RMDREVS; do
				[ "$x" = "$filename" ] || continue
#?				printf "\t  \033[31;2m-> %s\033[m\n" \
#?					"$file" >&2 # Testing -- Devin
				sudo rm -f "$file" >&2
				break
			done
			[ -e "$file" ] || continue
#?			printf "\t  \033[2m-> %s\033[m\n" \
#?				"$file" >&2 # Testing -- Devin
			case "$file" in
			*.jnl) # Journal file
				msg "WARNING: $file exists" \
				    "(\`rndc freeze' may be required)" >&2
				continue ;;
			esac
			zone="${file##*/}"
			if grep -q "$ip4arpa" "$file"; then
				printf 'zone "%s.in-addr.arpa" in {\n' "$zone"
				printf '\ttype master;\n'
				printf '\tfile "%s";\n' "$file"
				printf '\tnotify yes;\n'
				printf '};\n'
			fi
			if grep -q "$ip6arpa" "$file"; then
				printf 'zone "%s.ip6.arpa" in {\n' "$zone"
				printf '\ttype master;\n'
				printf '\tfile "%s";\n' "$file"
				printf '\tnotify yes;\n'
				printf '};\n'
			fi
		done; } | sudo tee "$view/include/rev.conf" > /dev/null
	done
	cd - > /dev/null
}

############################################################ OP FUNCTIONS
# Functions to operate dns change mechanism and interact with user

# dnsreload
#
# Reload the master Bind named process.
#
dnsreload()
{
	local file
	local res
	local view

#?	clear # Testing -- Parker
	sep "# nsadmin: Local Bind Reload"
	msg "Reloading Bind: $( date )"

	echo
	sudo service named restart
	sleep 1
	if ! pgrep named > /dev/null; then
		msg "ERROR: named is not running after reload: $( date )"

		msg "ERROR: attempting manual restart: $( date )"
		sudo service named start
		if pgrep named > /dev/null; then
			msg "Manual restart succeeded: $( date )"
			UPDATE=0
			return
		fi

		msg "ERROR: manual restart failed: $( date )"
		msg "ERROR: attempting to roll-back: $( date )"

		cd "$nameddir"
		for view in $views; do
			for file in $( find "$view" -name ".bak-*" ); do
				res=$( echo "$file" | sed -e "s/.bak-//" )
				sudo mv "$file" "$res"
			done
		done
		cd - > /dev/null

		sudo service named start
		if pgrep named > /dev/null; then
			msg "Roll-back succeeded: $( date )"
			UPDATE=0
			return
		fi

		if [ "$critical" ]; then
			echo "$USER: $( date )" | mail \
				${domain:+-r "$USER@$domain"} \
				-s "nsadmin: roll-back failed" "$critical"
		fi
		fatal "roll-back failed ... giving up" # NOTREACHED
		UPDATE=2

	fi

	UPDATE=0 # successful update/reload
}

# fatal $text ...
#
# Generate a fatal error message and exit this program.
#
fatal()
{
	logger -p user.crit -t "FATAL ERROR" "$*"
	echo
	echo " Fatal Error: $*" | tee -a "$log"
	echo
	[ "$ROOTFAIL" ] && rm -f "$log"
	exit $FAILURE
}

# sep [-dn] [-c color] $text ...
#
# Generate a separator on stdout.
#
sep()
{
	local color="34;"
	local sepsep="$SEP"
	local OPTIND=1 OPTARG flag

	while getopts c:dn flag; do
		case "$flag" in
		c) color="$OPTARG${OPTARG:+;}" ;;
		d) sepsep="$SEPDBL" ;;
		n) sepsep= ;;
		esac
	done
	shift $(( $OPTIND - 1 ))

	printf "\033[%s1m%s\n%s\n%s\n\033[m\n" \
		"$color" "$sepsep" "$*" "$sepsep"
}

# log [-dn] $text ...
#
# Generate a separator in the log.
#
log()
{
	local logsep="$SEP"
	local OPTIND=1 OPTARG flag

	while getopts dn flag; do
		case "$flag" in
		d) logsep="$SEPDBL" ;;
		n) logsep= ;;
		esac
	done
	shift $(( $OPTIND - 1 ))

	printf "%s\n%s\n%s\n\n" "$logsep" "$*" "$logsep" >> "$log"
}

# msg $text ...
#
# Generate a message in terminal, log file, and syslog.
#
msg()
{
	local msg="$*"

	printf "\n%s\n\n" "$msg"
	printf "\n%s\n\n" "$msg" >> "$log"
	logger -p user.info -t Info "$msg"
}

# sigquit
#
# Process a set of commands when a signal is caught by trap.
#
sigquit()
{
	trap - EXIT SIGHUP SIGINT SIGQUIT SIGTERM

	local date
	local excl
	local file
	local move from to
	local res
	local skip
	local subj

	stty echo
	echo

	LESSSECURE=

	cd "$nsadmindir"

	if [ ${UPDATE:=0} -eq 1 ]; then
		msg "ERROR: nsadmin killed after changes were" \
		    "made to master files: rolling back"
		for file in .bak-*; do
			[ -e "$file" ] || continue
			res=$( echo "$file" | sed -e s/.bak-// )
			cp "$file" "$res" > /dev/null 2>&1
		done
		checkin
		subj="nsadmin: ERROR: $( date ): $USER"
	elif [ ${UPDATE:=0} -eq 2 ]; then
		msg "ERROR: nsadmin killed after files were" \
		    "updated in the NAMEDB directory: rolling back"
		for file in .bak-*; do
			[ -e "$file" ] || continue
			res=$( echo "$file" | sed -e s/.bak-// )
			cp "$file" "$res"
		done
		checkin
		msg "ERROR: rolling back NAMEDB zone files"
		subj="nsadmin: ERROR: $( date ): $USER"
	else
		checkin
		subj="nsadmin: $( date ): $USER"
	fi

	if [ "$MVJNLREV" ]; then
		msg "ERROR: nsadmin killed after zones were moved:" \
		    "rolling back"
		# Play each move in reverse order to undo all moves
		for move in $MVJNLREV; do
			from="${move%%->*}"
			to="${move#"$from"->}"
			# NB: Earlier chown to user prevents need for sudo
			# which could prevent exit if validation timed-out.
			# Leaving files owned by last user is OK.
			[ -e "$to" ] && mv "$to" "$from"
			[ -e "RCS/$to,v" ] &&
				mv "RCS/$to,v" "RCS/$from,v"
		done
	fi

	# Checkout zones that were rm'd before we could regenerate configs
	if [ "$RMDZONES" ]; then
		msg "ERROR: nsadmin killed after zones were removed:" \
		    "rolling back"
		for file in $RMDZONES; do
			# Do not attempt to check out rm'd rev maps
			case "$file" in
			/*) checkout "$file" ;;
			esac
		done
		checkin
		subj="nsadmin: $( date ): $USER"
	fi

	# Remove unblank/new zones that were resurrected before genconf()
	if [ "$NEWZONES" ]; then
		msg "ERROR: nsadmin killed after zones resurrected:" \
		    "rolling back"
		for file in $NEWZONES; do
			case "$file" in
			/*) # Full path
				rm -f "$file"
				;;
			*) # Relative path
				rm -f "$nsadmindir/$file"
			esac
		done
	fi

	date=$( date )
	sep -n -c 2 " Finished: $date"
	echo >> "$log"
	log " Finished: $date"
	if [ "$admin" ]; then
		cat "$log" | mail ${domain:+-r "$USER@$domain"} \
			-s "$subj" "$admin"
	fi

	# We previously deleted these with sudo in predit()
	# NB: These should all be removable without sudo now
	rm -rf "$lock" "$log" "$tmp" .bak-* .revunq .updzones .view*

	# XXX Save the older version in case of emergency
	#sudo find "$nameddir" -name ".bak-*" -exec rm -f {} \;

	#
	# Make sure files are not left in a write state as it will
	# generate errors.
	#
	for file in *; do
		[ -e "$file" ] || continue
		skip=
		for excl in $exclude; do
			[ "$file" = "$excl" ] || continue
			skip=1
			break
		done
		[ "$skip" ] || chmod a-w "$file" > /dev/null 2>&1
	done

	cd - > /dev/null 2>&1
}

# zonemenu
#
# Print the list of zones and prompt for user selection.
#
zonemenu()
{
	local zone rest
	local from to

	while :; do
		zonelist

		printf "\n\033[1m Please choose a zone to"
		if [ "$EDITMODE" ]; then
			printf " edit "
		elif [ "$SYNC" ]; then
			printf " sync "
		else
			printf " view "
		fi
		printf "or 'q' to quit:\033[m "
		read zone rest
		echo

		if [ "$zone" = Q ] || [ "$zone" = q ]; then
			break
		fi

		if [ "$EDITMODE" ]; then # Edit commands
			case "$zone" in
			/q|/Q) # Same as Q or q above
				break ;;
			/diff)
				diffzone $rest
				continue ;;
			/log|/new|/rm)
				case "$rest" in
				*[!0-9a-zA-Z-.]*) # Invalid argument
					eval ${zone#/}zone ;;
				*)	eval ${zone#/}zone $rest
				esac
				continue ;;
			/mv)
				from="${rest%%[$IFS]*}"
				to="${rest#"$from"}"
				while [ "$to" != "${to#[$IFS]}" ]; do
					to="${to#[$IFS]}"
				done
				if [ "$to" -a ! "$from" ]; then
					from="$to"
					to=
				fi
				case "$from$to" in
				*[!0-9a-zA-Z.-]*) # Invalid arguments
					mvzone ;;
				*)	mvzone $from $to
				esac
				continue ;;
			/*)
				continue ;;
			esac
		else # View commands
			case "$zone" in
			/q|/Q) # Same as Q or q above
				break ;;
			/diff)
				diffzone $rest
				continue ;;
			/log)
				case "$rest" in
				*[!0-9a-zA-Z-.]*) # Invalid argument
					eval ${zone#/}zone ;;
				*)	eval ${zone#/}zone $rest
				esac
				continue ;;
			/*)
				continue ;;
			esac
		fi

		echo
		if [ ! "$zone" ]; then
			continue
		elif [ ! -f "$zone" ]; then
			msg "   Zone file not found: '$zone'"
			[ -e "RCS/$zone,v" ] &&
				printf "     Use \`/new $zone' to restore.\n\n"
			pause
			continue
		fi

		if [ "$EDITMODE" ]; then
			cp "$zone" ".bak-$zone" > /dev/null 2>&1
			editmaster "$zone"
		elif [ "$SYNC" ]; then
			if [ "$UPDZONES" ]; then
				if ( ! echo "$UPDZONES" | egrep \
		    		    "(^| |	)$zone(	| |$)" \
		    		    > /dev/null 2>&1 ); then
					UPDZONES="$UPDZONES $zone"
				fi
			else
				UPDZONES="$zone"
			fi
		else
			colorize "$zone" | ${PAGER:-less -R}
		fi
	done
}

# pause
#
# Wait for user to press return to continue.
#
pause()
{
	local ignored

	printf "\n \033[1m< Press return to continue >\033[m "
	stty -echo
	read ignored
	stty echo
	echo
}

# newzone [zone]
#
# Handler for the /new zone menu edit command.
#
newzone()
{
	local err
	local checkout new
	local append n
	local zone

	if [ "$1" ]; then
		zone="$1"
	else
		printf "  Enter a name for new zone: "
		read zone
	fi

	case "$zone" in
	"") return ;;
	..|.|*/*)
		msg "  Invalid zone \`$zone': $( date )"
		pause
		return
		;;
	esac

	local file="$nsadmindir/$zone"
	local rcsfile="$nsadmindir/RCS/$zone,v"

	if [ -e "$file" ]; then
		msg "   Zone $zone already exists: $( date )"
		pause
		return
	fi

	# Zone file does not exist

	if [ -e "$rcsfile" ]; then
		msg "   RCS file ${rcsfile##*/} exists: $( date )"
		printf "  Checkout %s%s? [Y/n]: " "${rcsfile##*/}" "$(
			rcs log "$rcsfile" |
				awk 'sub(/head: /,""){print;exit}' 2> /dev/null
		)"
		read checkout
		echo
		case "$checkout" in
		[Nn]|[Nn][Oo]) checkout= ;;
		*) checkout=1
		esac

		if [ "$checkout" ]; then
			if ! checkout -uv "$zone"; then
				msg "   Zone checkout failed: $( date )"
			else
				msg "   Zone $zone checked out: $( date )"
				CHANGES=1

				# Append zone to list of those newly co'd
				# NB: Allows us to rm it on unclean exit
				append=1
				for n in $NEWZONES; do
					[ "$n" != "$zone" ] && continue
					append=
					break
				done
				[ "$append" ] &&
					NEWZONES="$NEWZONES${NEWZONES:+ }$zone"
			fi
			pause
			return
		fi

		printf "  Create new %s zone? [N/y]: " "$zone"
		read new
		echo
		case "$new" in
		[Yy]|[Yy][Ee][Ss]) new=1 ;;
		*) new=
		esac

		if [ ! "$new" ]; then
			msg "   Zone not checked out, not created: $( date )"
			pause
			return
		fi
	fi

	if ! err=$( newzonefile "$zone" "$file" 2>&1 ); then
		msg "   $err"
		pause
		return
	fi

	echo
	rcs -l "$file"
	echo "$USER: $( date )" | ci -u "$file"
	sudo chown "$binduser:$bindgroup" "$rcsfile"
	sudo chmod 0660 "$rcsfile"

	msg "   Created $zone zone: $( date )"
	pause
}

# newzonefile $zone $file
#
# Initialize new zone file contents.
#
newzonefile()
{
	local zone="$1"
	local file="$2"
	cat > "$file" <<-EOF
	;---------------------------------------------------------------------
	; $zone zone map
	;---------------------------------------------------------------------
	; vi:ft=bindzone


	EOF
}

# rmzone [$zone]
#
# Handler for the /rm zone menu edit command.
#
rmzone()
{
	local ans
	local file
	local subnets
	local x r
	local zone

	if [ "$1" ]; then
		zone="$1"
	else
		printf "  Enter the name of the zone to remove: "
		read zone
	fi

	case "$zone" in
	"") return ;;
	..|.|*/*)
		msg "  Invalid zone \`$zone': $( date )"
		pause
		return
		;;
	esac

	file="$nsadmindir/$zone"

	if ! [ -e "$file" ]; then
		msg "Zone $zone does not exist: $( date )"
		pause
		return
	fi

	printf "\n \033[1mAre you sure you want to remove $zone [N/y]?\033[m "
	read ans
	case "$ans" in
	[Yy]|[Yy][Ee][Ss]) : ok ;;
	*) return
	esac

	# Get a list of rev maps that we need to zero-out
	subnets=$( zone2rev -r "$file" )

	if ! sudo rm -f "$file"; then
		pause
		return
	fi

	RMDZONES="$RMDZONES${RMDZONES:+ }$file${subnets:+ }$subnets"
	[ "$subnets" ] && RMDREVS="$RMDREVS${RMDREVS:+ }$subnets"

	# Elide removed zone from NEWZONES and UPDZONES
	r=
	for x in $NEWZONES; do
		[ "$x" = "$zone" -o "$x" = "$file" ] && continue
		r="$r${r:+ }$x"
	done
	NEWZONES="$r"
	r=
	for x in $UPDZONES; do
		[ "$x" = "$zone" -o "$x" = "$file" ] && continue
		r="$r${r:+ }$x"
	done
	UPDZONES="$r"

	CHANGES=1
	msg "   Removed $zone zone: $( date )"
	sleep 1
}

# mvzone [$from [$to]]
#
# Handler for the /mv zone menu edit command.
#
mvzone()
{
	local from to n
	local ans

	if [ "$1" ]; then
		from="$1"
	else
		printf "  Enter the name of the zone to move: "
		read from
	fi

	case "$from" in
	"") return ;;
	..|.|*/*)
		msg " Invalid zone \`$from': $( date )"
		pause
		return
		;;
	esac

	if [ ! -e "$from" ] && [ ! -e "RCS/$from,v" ]; then
		msg "Zone $from does not exist: $( date )"
		pause
		return
	fi

	if [ "$2" ]; then
		to="$2"
	else
		printf "  Enter new name: "
		read to
	fi

	case "$to" in
	"") return ;;
	..|.|*/*)
		msg " Invalid zone \`$to': $( date )"
		pause
		return
		;;
	esac

	if [ -e "$to" ]; then
		msg "Zone $to already exists: $( date )"
		pause
		return
	fi

	if [ -e "RCS/$to,v" ]; then
		msg "Cannot move $from, $to history exists: $( date )"
		printf "\n  Use \`/mv $to' to move zone history first.\n\n"
		pause
		return
	fi

	printf "\n \033[1mMove $from to $to [N/y]?\033[m "
	read ans
	case "$ans" in
	[Yy]|[Yy][Ee][Ss]) : ok ;;
	*)
		msg "   Cancelled, $from not moved to $to: $( date )"
		pause
		return
	esac

	#
	# Move files
	# NB: chown required so sigquit() can undo on interrupt (without sudo)
	#
	if ! sudo chown "$USER" "RCS/$from,v" ||
	   ! mv "RCS/$from,v" "RCS/$to,v"
	then
		msg "   Failed to move RCS/$from,v to RCS/$to,v: $( date )"
		pause
		return
	fi
	if ! sudo chown "$USER" "$from" ||
	   ! mv "$from" "$to"
	then
		msg "   Failed to move $from to $to: $( date )"
		pause
		return
	fi

	# Append action to forward move-jornal for commit
	MVJNL="$MVJNL${MVJNL:+ }$from->$to"

	# Prepend action to reverse move-journal for interrupt
	MVJNLREV="$from->$to${MVJNLREV:+ }$MVJNLREV"

	CHANGES=1
	msg "   Moved $from zone to $to: $( date )"
	pause
}

# logzone [$zone]
#
# Handler for the /log zone menu edit command.
#
logzone()
{
	local file rcsfile
	local zone

	if [ "$1" ]; then
		zone="$1"
	else
		printf "  Enter the name of the zone to view: "
		read zone
	fi

	case "$zone" in
	"") return ;;
	..|.|*/*)
		msg "  Invalid zone \`$zone': $( date )"
		pause
		return
		;;
	esac

	file="$nsadmindir/$zone"
	rcsfile="$nsadmindir/RCS/$zone,v"
	if [ ! -e "$file" ] && [ ! -e "$rcsfile" ]; then
		msg "Zone $zone does not exist: $( date )"
		pause
		return
	fi

	rlog "$file" 2>&1 |
		awk '!/^[[:space:]]*$/,0' | colorize | ${PAGER:-less -R}
}

# diffzone_usage $fmt [$args ...]
#
# Display usage statement for /diff command.
#
diffzone_usage()
{
	local cmd=/diff
	local fmt="$1"
	local optfmt="  \t%-9s %s\n"
	if [ "$fmt" ]; then
		shift 1 # fmt
		printf "%s: $fmt\n" "$cmd" "$@"
	fi
	printf "  Usage: %s [-r rev1 [-r rev2]] [zone]\n" "$cmd"
	printf "  Options:\n"
	printf "$optfmt" "-r rev" "Revision (zero, one, or two times)."
	printf "\n"
	printf "  If two revisions (-rREV1 -rREV2), compare revisions.\n"
	printf "  If one revision (-rREV), compare working file with it.\n"
	printf "  If no revisions, compare working file with latest.\n"
	printf "\n"
	pause
}

# diffzone [-rX.Y] [$zone]
#
# Handler for the /diff zone menu edit command.
#
diffzone()
{
	local OPTIND=1 OPTARG flag
	local rev1= rev2= zone=
	local file rcsfile diff

	while getopts hr: flag; do
		case "$flag" in
		r) # Revision
			if [ ! "$OPTARG" ]; then
				diffzone_usage "\`r rev' requires an argument"
				return
			fi
			if [ "$rev2" ]; then
				diffzone_usage "Too many \`-r rev' options"
				return
			elif [ "$rev1" ]; then
				rev2="$OPTARG"
			else
				rev1="$OPTARG"
			fi
			;;
		h) # Help
			diffzone_usage
			return ;;
		*) # Unknown
			diffzone_usage "$flag: Unknown option"
			return
		esac
	done
	shift $(( $OPTIND - 1 ))

	if [ "$EDITMODE" -a $# -eq 0 ] && ! [ "$rev1" -o "$rev2" ]; then
		# Executed without arguments in edit mode
		diff=$( for zone in $UPDZONES; do
			rcsdiff -q -u "$nsadmindir/$zone" 2>&1
		done )
		if [ ! "$diff" ]; then
			printf "  No differences.\n"
			pause
			return
		fi
		echo "$diff" | colorize | ${PAGER:-less -R}
		return
	fi

	if [ "$1" ]; then
		zone="$1"
	else
		printf "  Enter the name of the zone to diff: "
		read zone
	fi

	case "$zone" in
	"") return ;;
	..|.|*/*)
		msg "  Invalid zone \`$zone': $( date )"
		pause
		return
		;;
	esac

	file="$nsadmindir/$zone"
	if [ ! -e "$file" ]; then
		rcsfile="$nsadmindir/RCS/$zone,v"
		if [ ! -e "$rcsfile" ]; then
			msg "Zone $zone does not exist: $( date )"
			pause
			return
		elif ! [ "$rev1" -a "$rev2" ]; then
			printf "  Must use \`/diff -rREVA -rREVB $zone'.\n"
			printf "  See \`/log $zone' for a list of revisions.\n"
			pause
			return
		fi
	fi

	set -- -q ${rev1:+-r"$rev1"} ${rev2:+-r"$rev2"} -u "$file"
	diff=$( rcsdiff "$@" )
	if [ ! "$diff" ]; then
		printf "  No differences.\n"
		pause
		return
	fi
	rcsdiff "$@" 2>&1 | colorize | ${PAGER:-less -R}
}

############################################################ ZONE FUNCTIONS
# Functions to interact with master files and generated zones

# checkin
#
# Using RCS, check in the edited and verified master files.
#
checkin()
{
	local cnt=1
	local file rcsfile

	while eval [ \"\$colist_$cnt\" ]; do
		eval file=\"\$colist_$cnt\"
		cnt=$(( $cnt + 1 ))
		[ -e "$file" ] || continue
		rcsdiff -q "$file" > /dev/null 2>&1 && continue
		case "$file" in
		/*) rcsfile="${file%/*}/RCS/${file##*/},v" ;;
		 *) rcsfile="RCS/$file,v"
		esac
		sudo chown "$binduser:$bindgroup" "$file"
		sudo chmod 0440 "$file"
		rcs -l "$file"
		if [ "$COMMITMSG" ]; then
			printf "%s: %s\n\n%s\n" \
				"$USER" "$( date )" "$COMMITMSG" |
				ci -u "$file" #? > /dev/null 2>&1
		else
			printf "%s: %s\n" "$USER" "$( date )" |
				ci -u "$file" #? > /dev/null 2>&1
		fi
		sudo chown "$binduser:$bindgroup" "$rcsfile"
		sudo chmod 0660 "$rcsfile"
	done
}

# checkout [-uv] file
#
# Using RCS, check out the master file for editing.
#
checkout()
{
	local OPTIND=1 OPTARG flag
	local cnt=1
	local file
	local unlocked=
	local verbose=

	while getopts uv flag; do
		case "$flag" in
		u) unlocked=1 ;;
		v) verbose=1 ;;
		esac
	done
	shift $(( $OPTIND - 1 ))

	file="$1"
	if [ -e "$file" ]; then
		sudo chown "$USER" "$file"
		sudo chmod 0440 "$file"
	fi

	while eval [ \"\$colist_$cnt\" ]; do
		eval [ \"\$file\" = \"\$colist_$cnt\" ] && return
		cnt=$(( $cnt + 1 ))
	done
	eval colist_$cnt=\"\$file\"

	if [ "$unlocked" ]; then
		if [ "$verbose" ]; then
			co -u "$file"
		else
			co -u "$file" > /dev/null 2>&1
		fi
	else
		if [ "$verbose" ]; then
			:| co -l "$file"
		else
			:| co -l "$file" > /dev/null 2>&1
		fi
	fi
}

# getsubnets file
#
# Get only the subnets that changed in the master file edit.
#
getsubnets()
{
	local file="$1"
	local subnet

	for subnet in $( rcsdiff -uq "$file" | awk 'NR>2&&sub(/^[+-]/,"")' |
		zone2rev -l - )
	do
		# Only insert subnet if not existing in $subnets
		echo "$SUBNETS" | grep -q "\\<$(
			echo "$subnet" | sed -e 's/\./\\&/g'
		)$subnet\\>" || SUBNETS="$SUBNETS $subnet"
	done
	SUBNETS="${SUBNETS# }"
}

# pushzones
#
# Update the Bind zone files with the finished master files.
#
pushzones()
{
	local cmd
	local file
	local res
	local slave
	local view

#?	clear # Testing -- Parker
	sep "# nsadmin: Zone Push"
	msg " Executing local Push:"

	msg "	Backing up previous versions: $( date )"
	cd "$nameddir"
	for view in $views; do
		if [ ! -e "$view" ]; then
			sudo mkdir -p -m 1770 "$view"
			sudo chown "$binduser:$bindgroup" "$view"
		fi
		for dir in "$view/master" "$view/rev"; do
			[ ! -e "$dir" ] || continue
			mkdir -p -m 0770 "$dir"
			sudo chown "$binduser:$bindgroup" "$dir"
		done
		for file in $RMDZONES; do
			file="$view/master/${file##*/}"
			[ -e "$file" ] || continue
			printf "\t  \033[31;2m-> %s\033[m\n" "$file"
			sudo rm -f "$file"
		done
		for file in $( find "$view" -type f ! -name ".bak-*" ); do
			res=$( echo "$file" |
			    sed -e 's/\(.*\/\)\(.*\)/\1.bak-\2/' )
			cmp -s "$file" "$res" 2> /dev/null && continue
			printf "\t  \033[2m-> %s\033[m\n" "$file"
			sudo cp "$file" "$res"
		done
		echo
	done
	cd - > /dev/null

	msg "	Pushing local zones: $( date )"
	cd "$tmp"
	sudo chown -R "$binduser:$bindgroup" *
	sudo chmod -R g+w *
	find . -type f -exec sudo cp {} "$nameddir/{}" \;
	cd - > /dev/null

	msg "	Generating configs: $( date )"
	genconf $views

	msg "	Building zone tarball: $( date )"
	cd "$tmp"
	tar czpf zone.tgz *
	cd - > /dev/null
#?	sleep 2 # Testing -- Parker

	for slave in $SLAVES; do
#?		clear # Testing -- Parker
		sep "# nsadmin: Zone Push"
		msg " Executing remove push to $slave: $( date )"

		msg "	Copying zone tarball to $slave: $( date )"
		cmd="scp $scpopts $tmp/zone.tgz $user@$slave:tmp"
		sudo su - $user -c "$cmd"

		msg "	Executing push on $slave: $( date )"
		cmd="ssh $sshopts $slave"
		cmd="$cmd 'sudo /usr/local/bin/nsslave'"
		sudo su - $user -c "$cmd"

#?		sleep 2 # Testing -- Parker
	done
}

# verify file
#
# Verify changes in the zone files.
#
verify()
{
	local ans
	local diff
	local file="$1"
	local res
	local new zone

	if rcsdiff -q "$file" > /dev/null 2>&1; then
		ci -u "$file" > /dev/null 2>&1
		msg "No changes made to $file."
		pause

		# Remove zone from list of those that have been updated
		new=
		for zone in $UPDZONES; do
			[ "$zone" = "$file" -o \
			  "$zone" = "${file#"$nsadmindir/"}" ] && continue
			new="$new $zone"
		done
		UPDZONES="${new# }"

		# Reset change indicator if this edit reverted all changes
		[ "$UPDZONES$RMDZONES$NEWZONES$MVJNL" ] || CHANGES=

		return
	fi

	if res=$( zone2rev -V "$file" ); then
		vprompt "$file"
		return
	fi

	clear
	sep "# nsadmin: Verify Failure"
	msg "ERROR: incorrect A/AAAA record format"
	echo

	echo "$res" | tee -a "$log"
	diff=$( rcsdiff -u "$file" )
	echo "$diff" | colorize | ${PAGER:-less -F -R}
	echo "$diff" | awk '$0="  "$0' >> "$log"
	echo >> "$log"

	echo
	echo
	pause

	editmaster "$file"
}

# viewtest zone
#
# Test the view syntax in the master files.
#
viewtest()
{
	local file="$nsadmindir/$1"
	local view

	cat <<-EOF

	 Testing View Syntax:

	EOF

	rm -f .view*

	grep --line-number VIEW "$file" > .view
	grep -v "; VIEW: " .view >> .view-out
	grep , .view | grep -v ", " >> .view-out

	grep "; VIEW: " .view |
		sed -e "s/.*VIEW: //;s/,//g" > .view-list
	for view in $views; do
		sed -e "s/$view//g" .view-list > .n
		mv .n .view-list
	done
	egrep -v '^( $|$)' .view-list > .n
	mv .n .view-list

	# XXX YUK
	if [ -s .view-out ] || [ -s .view-list ]; then
		if [ -s .view-out ]; then
			sed -e 's/^\([0-9]*\):/line \1: /;s/^/	/' .view-out
			echo
			msg "ERROR: invalid view syntax, must use" \
			    "'; VIEW: <view>[, <view> ...]'"
		fi

		if [ -s .view-list ]; then
			sed -e "s/^/	unknown view: /" .view-list
			echo
			msg "ERROR: unknown views, valid views are" "'$views'"
		fi

		FAILTYPE=master
		FAILFILE="$1"

		return
	fi

	# checkin file on exit in sync mode (-s)
	if [ "$SYNC" ]; then
		SYNCCNT=$(( $SYNCCNT + 1 ))
		eval colist_$SYNCCNT=\"\$1\"
	fi

	echo "	OK"
	echo
}

# vprompt file
#
# User interaction within the verify() function.
#
vprompt()
{
	local ans
	local diff
	local file="$1"

	clear
	sep "# nsadmin: $file changes"

	diff=$( rcsdiff -u "$file" )
	echo "$diff" | colorize | ${PAGER:-less -F -R}
	echo "$diff" | awk '$0="  "$0' >> "$log"
	echo >> "$log"

	printf "\n\n"
	printf " \033[1mAccept these changes [(y)es | (n)o | (E)dit]:\033[m "
	read ans
	echo

	case "$ans" in
	[nN])	msg "$USER canceled changes: $( date )"
		cp ".bak-$file" "$file" > /dev/null 2>&1
		;;
	[yY])	echo
		msg "$USER accepted changes: $( date )"
		getsubnets "$file"
		UPDATE=1 # First stage of dns updates
		if [ "$UPDZONES" ] && ! echo "$UPDZONES" |
		    egrep "(^| |	)$file(	| |$)" > /dev/null 2>&1
		then
			UPDZONES="$UPDZONES $file"
		else
			UPDZONES="$file"
		fi
		echo
		CHANGES=1
		;;
	*)	msg "$USER re-editing $file; $( date )"
		editmaster "$file"
	esac
}

# zonelist
#
# List the currently active zones.
#
zonelist()
{
	local cmd
	local cnt
	local col=0
	local rcs=
	local tab=
	local zone zones

	clear
	if [ "$CHANGES" ]; then
		sep -c 31 "# nsadmin: Zone List (quit to save; ^C to revert)"
	elif [ "$EDITMODE" ]; then
		sep -c 32 "# nsadmin: Zone List (Edit Mode)"
	else
		sep "# nsadmin: Zone List"
	fi

	zones=$( for zone in [a-z0-9]* ${EDITMODE:+RCS/[a-z0-9]*,v}; do
		case "$zone" in
		RCS/*,v) # History file
			file="${zone#RCS/}"
			file="${file%,v}"
			[ -e "$file" ] && continue # See below
			echo "$file!"
			;;
		*[!a-zA-Z0-9.-]*) # Invalid name
			continue
			;;
		*) # Zone master file
			echo "$zone"
		esac
	done | sort )

	for zone in $zones; do
		case "$zone" in
		*!) # History file
			zone="${zone%!}"
			[ -e "RCS/$zone,v" ] || continue
			rcs=1
			;;
		*)
			[ -e "$zone" ] || continue
			rcs=
		esac
		if echo "$exclude" |
		    egrep "(^| |	)$zone(	| |$)" \
		    > /dev/null 2>&1
		then
			continue
		fi

		cnt=$(( ${#zone} + 1 ))
		if [ $cnt -lt 7 ]; then
			tab='\t\t\t'
		elif [ $cnt -lt 15 ]; then
			tab='\t\t'
		else
			tab='\t'
		fi
		if [ $col -ge 3 ]; then
			echo
			col=0
		fi
		if [ "$rcs" ]; then
			printf "  \033[2m%s\033[m$tab" "$zone"
		else
			printf "  %s$tab" "$zone"
		fi
		col=$(( $col + 1 ))
	done
	printf "\n\n"

	if [ "$EDITMODE" ]; then
		col=0
		printf " \033[1mEdit Commands:\033[m\n\n "
		for cmd in $EDITCMDS; do
			if [ $col -ge 6 ]; then
				printf "\n "
				col=0
			fi
			printf " %-12s" "$cmd"
			col=$(( $col + 1 ))
		done
		printf "\n\n"
	else
		col=0
		printf  " \033[1mView Commands:\033[m\n\n "
		for cmd in $VIEWCMDS; do
			if [ $col -ge 6 ]; then
				printf "\n "
				col=0
			fi
			printf " %-12s" "$cmd"
			col=$(( $col + 1 ))
		done
		printf "\n\n"
	fi
}

# zonetest
#
# Test the generated zones and rev maps.
#
zonetest()
{
	local file
	local _IFS="$IFS" IFS
	local res

	FAILFILE=
	FAILTYPE=

	for file in $( find "$tmp" -type f ); do
		IFS=/
		set -- ${file#"$tmp/"}
		IFS="$_IFS"

#?		clear # Testing -- Devin
		sep "# nsadmin: Zone Tests"
		cat <<-EOF
		 View:	$1
		 Type:	$2
		 Zone:	$3

		EOF

		if [ "$2" = master ]; then
			viewtest "$3"
			[ "$FAILTYPE" ] && return
		fi

		echo
		echo " Testing Bind Syntax:"

		if ! res=$( exec 2>&1
			name="$3"
			if [ "$2" = rev ]; then
				if [ "$3" != "${3#*.*.*.*.*}" ]; then
					name="$name.ip6.arpa"
				else
					name="$name.in-addr.arpa"
				fi
			fi
			( named-checkzone "$name" "$file" 2>&1;
			  echo :EXIT:$?
			) | awk '
				sub(/^:EXIT:/, "") { status = $0; next }
				match($0, /^[^[:space:]:]+:[0-9]+:/) {
					prefix = substr($0, 1, RLENGTH - 1)
					suffix = substr($0, RSTART + RLENGTH)
					sub(/[0-9]+$/, "", prefix)
					sub(".*/", "", prefix)
					$0 = prefix suffix
				}1
				END { exit status }
			' # END-QUOTE
		) && [ $( echo "$res" | wc -l ) -gt 2 ]; then
			FAILTYPE="$2"
			FAILFILE="$3"

			echo "$res" | sed -e 's/.*\///;s/^/	/'
			echo

			echo
			echo " Master File Diff:"
			rcsdiff -u "$nsadmindir/$3" 2>&1 |
				sed -e "s/^/	/"
			echo

			msg "ERROR: zone test failed on $FAILFILE"

			return
		fi

		echo "$res" | sed -e "s/^/	/"
		echo

#?		sleep 2 # Testing -- Parker
	done
}

############################################################ MAIN

#
# Process command-line options
#
while getopts "aehl:n:su:v?" flag; do
	case "$flag" in
	a) SYNCALL=1 ;;
	e) EDITMODE=1 ;;
	l) UPDZONES=$( echo "$OPTARG" | sed -e "s/,/ /g" ) ;;
	n) SLAVES=$( echo "$OPTARG" | sed -e "s/,/ /g" ) ;;
	s) SYNC=1 ;;
	u) USER="$OPTARG" ;;
	v) VERSION="${VERSION#*: }"
		echo "${VERSION% $}"
		exit $SUCCESS ;;
	*) usage # NOTREACHED
	esac
done
shift $(( OPTIND - 1 ))

#
# OS Glue
#
case "$UNAME_s" in
*BSD*) NSADMIN_CONF="/usr/local/etc/$NSADMIN_CONF" ;;
*) NSADMIN_CONF="/etc/$NSADMIN_CONF"
esac

#
# Load config
#
__slaves="$SLAVES"
. "$NSADMIN_CONF" || exit
[ "$__slaves" ] && SLAVES="$__slaves"

# Make sure log exists
[ "$log" ] ||
	fatal "${NSADMIN_CONF##*/}: log variable unset or NULL" # NOTREACHED

#
# $USER required for all logging and auditability for edit/sync modes
#
if [ "$EDITMODE$SYNC" ]; then
	if [ "$( id -nu )" = root ]; then
		if [ ! "$USER" ]; then
			ROOTFAIL=1
			fatal "root must pass \`-u user' with \`-e' or \`-s'"
			# NOTREACHED
		fi
		# Validate that the given user exists
		_USER=$( id -nu "$USER" 2> /dev/null ) ||
			fatal "user \`$USER' does not exist" # NOTREACHED
		USER="$_USER"
		unset _USER
	elif [ "$USER" ]; then
		ROOTFAIL=1
		fatal "only root can use \`-u user'"
		# NOTREACHED
	else
		USER=$( id -nu )
	fi
fi

#
# Setup
#
if [ ! -e "$nsadmindir" ]; then
	printf "\n\033[2m Setting up...\033[m\n\n"
	case "$nsadmindir" in
	*/*)
		parentdir="${nsadmindir%/*}"
		if [ ! -e "$parentdir" ]; then
			sudo mkdir -p -v "$parentdir" || exit $FAILURE
		fi
		unset parentdir
		;;
	esac
	sudo mkdir -p -v -m 1770 "$nsadmindir" || exit $FAILURE
	sudo chown "$binduser:$bindgroup" "$nsadmindir" || exit $FAILURE
fi
cd "$nsadmindir" || exit

#
# Configuration defaults
#
: ${views:=$pgm}

#
# Process -a
#
if [ "$SYNCALL" ]; then
	for file in *; do
		[ -e "$file" ] || continue
		skip=
		for excl in $exclude; do
			[ "$file" = "$excl" ] || continue
			skip=1
			break
		done
		if [ ! "$skip" ] && [ ! "$UPDZONES" ]; then
			UPDZONES="$file"
		elif [ ! "$skip" ]; then
			UPDZONES="$UPDZONES $file"
		fi
	done
fi

#
# Validate command-line arguments
#
if [ "$UPDZONES" ] && [ ! "$SYNC" ]; then
	msg "ERROR: '-l' or '-a' requires '-s'"
	usage # NOTREACHED
fi

umask 0022
LESSSECURE=1 # Disable edit functions

#
# Check for duplicate instances
#
pids=
for pid in $( pgrep -f "/bin/(ba)?sh $0([[:space:]]|$)" 2> /dev/null ); do
        case "$pid" in $$|$PPID) continue; esac
        ps -p $pid > /dev/null 2>&1 || continue
        pids="$pids $pid"
done
if [ "$pids" ]; then
        echo "Already running:" $pids
        exit $FAILURE
fi

#
# Setup
#
if [ ! -e "$nsadmindir/RCS" ]; then
	mkdir -p -m 0770 "$nsadmindir/RCS"
	sudo chown "$bindgroup:$binduser" "$nsadmindir/RCS" || exit $FAILURE
fi

# Make sure only one person is building zone files at a time
if [ "$EDITMODE" ] || [ "$SYNC" ]; then
	getlock
	predit
fi

# Display zone menu unless -a/-l given
[ "$UPDZONES" ] || zonemenu

#
# If there are changes to the master files, generate the zones
#
[ "$UPDZONES$NEWZONES$RMDZONES$MVJNL" ] || exit $SUCCESS
if [ "$MVJNL" ]; then
	# Process move journal to determine what's new/removed
	for u in $( for move in $MVJNL; do
		from="${move%%->*}"
		to="${move#"$from"->}"
		printf "%s\n%s\n" "$from" "$to"
	done | sort -u ); do
		if [ -e "$u" ]; then
			UPDZONES="$UPDZONES${UPDZONES:+ }$u"
		else
			RMDZONES="$RMDZONES${RMDZONES:+ }$u"
		fi
	done
fi
if [ "$NEWZONES" ]; then
	# Mark new zones as updated so that they get published
	for n in $NEWZONES; do
		u=
		for u in $UPDZONES; do
			[ "$u" = "$n" ] && break
		done
		[ "$u" = "$n" ] && continue
		UPDZONES="$UPDZONES${UPDZONES:+ }$n"
	done
fi
if [ "$SYNC" ]; then
	msg "File generation called by sync option."
	msg "Files: $UPDZONES"
else
	# We need a description of why this is being done
	exec 3<&1
	COMMITMSG=$(
		set -e
		tmpfile=$( mktemp -t "$pgm.XXXXXXXX" )
		awk 'sub(/^\t+/,"")||1' >> "$tmpfile" <<-EOF


		# Please enter some text describing your changes
		#
		# IMPORTANT! Lines at the bottom beginning with # are ignored
		# IMPORTANT! At least one non-blank line above is required
		#
		# WARNING! Changes will be aborted without a message
		EOF
		trap 'rm -f "$tmpfile" > /dev/null 2>&1' EXIT
		${EDITOR:-vi} "$tmpfile" >&3
		msg=$( awk '
			BEGIN {
				delete buf
				blank = "^[[:space:]]*(#|$)"
				comment = "^[[:space:]]*#"
			}
			{ buf[NR] = $0 }
			END {
				for (n = NR; n > 0; n--)
					if (buf[n] !~ blank) break
				stop = (buf[n] ~ blank) ? n - 1 : n
				skip = 1
				line = 0
				for (n = 1; n <= stop; n++) {
					if (buf[n] ~ blank && skip)
						continue
					else if (buf[n] ~ blank) {
						if (line) continue
						print ""
						line = 1
					}
					else if (buf[n] !~ comment) {
						skip = line = 0
						print buf[n]
					}
				}
			}
		' "$tmpfile" )
		cat "$log" > "$tmpfile"
		if [ ! "$msg" ]; then
			msg="WARNING! No message entered. Cancelling."
			echo "$msg" >&2
			echo "$msg" > "$log"
			echo >> "$log"
			cat "$tmpfile" >> "$log"
			exit $FAILURE
		fi
		echo "$msg" > "$log"
		echo >> "$log"
		cat "$tmpfile" >> "$log"
		echo "$msg" # To $COMMITMSG
	) || exit
fi
genmaster
pushzones
dnsreload
MVJNLREV=
NEWZONES=
RMDZONES=

exit $SUCCESS

################################################################################
# END
################################################################################
