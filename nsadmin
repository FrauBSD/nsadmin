#!/bin/sh
#-
# Copyright (c) 2006-2013 Parker Lee Ranney TTEE
# Copyright (c) 2017-2019 Devin Teske <dteske@FreeBSD.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
############################################################ IDENT(1)
#
# $Title: Distributed bind9 administration and management tool $
# $Id: nsadmin,v 1.1 2012/05/09 21:39:43 root Exp $
# $Copyright: 2017-2019 Devin Teske. All rights reserved. $
# $FrauBSD: nsadmin/nsadmin 2019-10-05 13:32:40 -0700 freebsdfrau $
#
############################################################ INFORMATION
#
# nsadmin -- Update Bind's installation on the master NS server. RCS
# 	is used for file history. All updates will be sent out as an
# 	email to the appropriate admin address. A lock is kept during
# 	the run of this program to prevent conflicting updates.
#
# --------------------------------------------------------------------
# Notes:
# 	- Requires bind server and nsadmin.conf on the master.
# 	- Requires nsslave and nsslave-var.inc on the slave Bind
# 	  servers to operate.
# 	- User 'cm' and the authorized_keys2 file for that user must
# 	  be installed on all slave Bind servers. The 'cm' user account
# 	  and ID file must be on the server with this script.
# 	- User 'cm' must be able to remotely execute via SSH the
# 	  following command:
# 		sudo /usr/local/bin/nsslave
# 	  Without password on the slave Bind servers.
# 	- Users must be placed in the DNSOPS group in sudoers as a
# 	  result of the commands that require root access.
# 	- Users must also belong to the "bind" group in /etc/group to
# 	  edit the files.
# --------------------------------------------------------------------
# History:
# 	Jul 2019: Release 3.1
# 		- Initial Public release.
# 		- Enable restriction to prevent anonymous root access.
# 		- Add secondary variable to `nsadmin-var.inc'.
# 		- Fix hard-coded primary/secondary in `GEN FUNCTIONS'.
# 	Jul 2018: Release 3.0
# 		- Major rewrite and code cleanup.
# 		- Improved error checking of zone files.
# 		- Support IPv6 AAAA records.
# 	Jul 2018: Release 2.6
# 		- Fix bug preventing some reverse entries from being created
# 	Jul 2018: Release 2.5
# 		- Fix bug preventing reverse lookup of A records ending in
# 		  .0 or .255
# 	Jul 2017: Release 2.4
# 		- Ask the user for a message to describe changes.
# 		- Only allow one instance of nsadmin at a time.
# 	Jun 2017: Release 2.3
# 		- Add `-n slaves' syntax for selecting a subset of slaves.
# 		- Ported to FreeBSD.
# 	Mar 2010: Release 2.2
# 		- Fixed comments.
# 	Jul 2006: Release 2.1
# 		- Modified to migrate zones manually as IXFR and AXFR
# 		  are not reliable.
# 	Jun 2006: Release 2.0
# 		- Major rewrite and creation of includes.
# 		- Syntax checking.
# 		- Update only the rev maps with a changed IP.
# 		- Added read-only interface.
# 		- Added ability to generate zone files and rev maps
# 		  from the master files without performing updates,
# 		  known as sync.
# 	Apr 2006: Release 1.0
# 		- Basic interface and zone generation.
# --------------------------------------------------------------------
# To Do:
# 	- If a new rev map is created or a new zone file appears,
# 	  prompt the user to add rev map or zone to the include files.
# 		- Make this functionality require a command-line flag.
# 	- Change testing of variable list additions into a function.
# 	- zonetest():
# 		- named-checkzone returns line numbers of the final
# 		  zone file. Subtract 8 to get master file line number.
#
############################################################ INCLUDES

. /etc/nsadmin.conf || exit

############################################################ GLOBALS

pgm="${0##*/}" # Program basename
progdir="${0%/*}" # Program directory

PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

#
# Global exit status
#
SUCCESS=0
FAILURE=1

#
# Command-line options
#
syncall=	# -a

############################################################ FUNCTIONS

# usage
#
# Print the help menu and exit.
#
usage()
{
	exec >&2
	echo
	echo "  Usage: $pgm ..."
	echo
	echo "    Edit Mode:"
	echo "	Used to edit the master $pgm files:"
	echo
	echo "		$pgm [-n slaves] -e"
	echo
	echo "    Review Mode: (Default)"
	echo "	Used to view the master $pgm files:"
	echo
	echo "		$pgm"
	echo
	echo "    Sync Mode:"
	echo "	Used to update the Bind zone files with the data from"
	echo "	the master $pgm files. This does not allow"
	echo "	editing of the master files:"
	echo
	echo "		$pgm -s [-ah?] [-n slaves] -l <file>[,<file>, ..."
	echo
	echo "		-a			Sync all master files."
	echo "		-l <file>[,<file>]	Sync list of files."
	echo "		-n <slave>[,<slave>]	Override list of slaves."
	echo

	exit $FAILURE
}

############################################################ EDIT FUNCTIONS
# Functions to edit/change master files for zone and rev maps

# editmaster zone
#
# Edit the master files.
#
editmaster()
{
	local file="$1"

	cat >> "$log" <<-EOF
	$sepdbl
	Editing $file
	$sepdbl

	EOF

	cd "$nsadmindir"
	checkout "$file"

	${EDITOR:-vi} "$file"
	verify "$file"

	cd - > /dev/null
}

# getlock
#
# Establish an exclusive lock for master file edits.
#
getlock()
{
	local clobber=
	local res

	if [ -f "$lock" ]; then
		res=$( ls -l "$lock" | awk '{print $3}' )
		fatal "lock file exists, owner is $res" # NOTREACHED
	fi

	[ "$-" = "${-#*C}" ] && clobber=1
	set -C
	echo $$ > "$lock" || fatal "could not create '$lock'" # NOTREACHED
	[ "$clobber" ] && set +C
}

# predit
#
# Prepare the editing of the master files.
#
predit()
{
	trap "sigquit; exit" EXIT SIGHUP SIGINT SIGQUIT SIGTERM

	msg "$USER starting edits: $( date )"

	sudo rm -rf "$lock" "$log" "$tmp" .bak-* .revunq .updzones .view*

	cat > "$log" <<-EOF

	$sep
	 Starting: $( date )
	$sep

	EOF

	mkdir -p "$tmp"
}

# clear
#
# Like clear(1) but preserve scrollback.
#
clear()
{
	local size rows cols
	size=$( stty size 2> /dev/null )
	set -- ${size:-24 80}
	rows="$1"
	cols="$2"
	printf "\e[${rows}S\e[H"
}

############################################################ GEN FUNCTIONS
# Functions to generate zone files and reverse maps

# genmaster
#
# Generate the zone files and rev maps.
#
genmaster()
{
	local ans
	local file
	local subnet

	#
	# Save the master files that have changes to make sure they
	# are not lost in the loop'ing below.
	#
	echo "$updzones" > "$nsadmindir/.updzones"

	#
	# Generate a list of all subnets in the master file
	#
	if [ "$sync" ]; then
		for subnet in $(
			for file in $updzones; do
				zone2rev.awk -v file="$file" -v list_subnets=1
			done | sort -u
		); do
			# Only insert subnet if not existing in $subnets
			echo "$subnets" | grep -q "\\<$(
				echo "$subnet" | sed -e 's/\./\\&/g'
			)$subnet\\>" || subnets="$subnets $subnet"
		done
		subnets="${subnets# }"
	fi

	#
	# Loop through the zone file generation until each error is
	# fixed. Slave systems will not sync bad zone files nor will
	# the master load them.
	#
	while :; do
		echo
		msg "Building zone files and revmaps: $( date )"
		genzone $( cat "$nsadmindir/.updzones" )
		genrev

		zonetest
		[ "$failfile" ] || break

		printf "\nPress return when ready to re-edit."
		stty -echo
		read ans # ignored
		stty echo

		# Clean up the previous attempt
		find "$tmp" -type f -exec rm -f {} \;

		#
		# XXX Use the rcsdiff output to find the correct
		# XXX zone to edit instead of relying on the user to
		# XXX remember which file had errors.
		#
		if [ "$failtype" = rev ]; then
			zonemenu
		else
			editmaster "$failfile"
		fi
	done
}

# genrev
#
# Generate the reverse maps.
#
genrev()
{
	local excl
	local file
	local list
	local origin
	local rev
	local revfile
	local subnet
	local view

	cd "$nsadmindir"
	for view in $views; do

		list=$( ls -d [a-z0-9]* )
		for excl in $exclude; do
			list=$( echo "$list" | sed -e "s/$excl//" )
		done

		for file in $list; do
			for subnet in $subnets; do
				sudo zone2rev.awk -v view="$view" \
					-v file="$file" -v subnet="$subnet" \
					> /dev/null 2>&1
			done
		done

		for file in .new-*; do
			[ -e "$file" ] || continue

			revfile=$( echo "$file" | sed -e "s/^.new-//" )
			case "$revfile" in
			*.*.*.*.*) origin="$revfile.ip6.arpa." ;;
			*) origin="$revfile.in-addr.arpa." ;;
			esac
			rev="$tmp/$view/rev/$revfile"

			revunq "$file"

			awk 'sub(/^\\t/,"\t")||1' > "$rev" <<-EOF
			\$TTL $ttl
			@ IN SOA $primary. $contact. (
			\t		$serial	; serial
			\t		$refresh		; refresh
			\t		$retry		; retry
			\t		$expire		; expire
			\t		$minimum )		; minimum
			\t		IN NS $primary.
			\t		IN NS $secondary.
			\$ORIGIN $origin
			EOF
			grep -v ";" "$file" >> "$rev"

			rm -f "$file"
		done
	done
	cd - > /dev/null
}

# genzone zone ...
#
# Generate the master zone files.
#
genzone()
{
	local file
	local list="$*" # edited zones
	local origin
	local view

	for view in $views; do
		mkdir -p "$tmp/$view/master" "$tmp/$view/rev"
	done

	for view in $views; do
		cd "$tmp/$view/master"

		for file in $list; do

			origin="$file."

			awk 'sub(/^\\t/,"\t")||1' > "$file" <<-EOF
			\$TTL $ttl
			@ IN SOA $primary. $contact. (
			\t		$serial	; serial
			\t		$refresh		; refresh
			\t		$retry		; retry
			\t		$expire		; expire
			\t		$minimum )		; minimum
			\t		IN NS $primary.
			\t		IN NS $secondary.
			\$ORIGIN $origin
			EOF

			#
			# Keep any semicolons within a quoted TXT
			# record. Clear away all others.
			#
			awk -v view="$view" '
			!/^[[:space:]]*(;|$)/ {
				if (/;*VIEW:/ && $0 !~ view) next
				if (/".*;.*"/)
					sub(/; VIEW:.*/, "")
				else
					sub(/;.*/, "")
				print
			}' "$nsadmindir/$file" >> "$file"
		done

		cd - > /dev/null
	done
}

# revunq file
#
# Generate a rev map file with unique PTR records based on resulting hostname
# pointers.
#
revunq()
{
	local file="$1"

	awk -v file="$file" '
	function posnum(str)
	{
		if (str ~ /ns[0-9]*\.example\.com/) return 6
		if (str ~ /mx[0-9]*\.googlemail\.com/) return 6
		if (str ~ /\..*\.example\.com/) return 5
		if (str ~ /\.example\.com/) return 4
		if (str ~ /\.example\./) return 3
		return 1
	}
	BEGIN {
		delete host
		while (getline < file > 0) {
			if (!($1 in host)) host[$1] = $3
			else if (posnum(host[$1]) < posnum($3)) host[$1] = $3
		}
		for (unit in host) printf("%s%s\t\tPTR\t%s\n",
			unit, length(unit) <= 3 ? "\t\t\t" : "", host[unit])
	}
	' > .revunq

	sudo mv .revunq "$file"
}

############################################################ OP FUNCTIONS
# Functions to operate dns change mechanism and interact with user

# dnsreload
#
# Reload the master Bind named process.
#
dnsreload()
{
	local file
	local res
	local view

#?	clear # Testing -- Parker
	cat <<-EOF
	$sep
	# nsadmin: Local Bind Reload
	$sep

	EOF

	msg "Reloading Bind: $( date )"

	echo
	sudo service named restart
	sleep 1
	if ! pgrep named > /dev/null; then
		msg "ERROR: named is not running after reload: $( date )"

		msg "ERROR: attempting manual restart: $( date )"
		sudo service named start
		if pgrep named > /dev/null; then
			msg "Manual restart succeeded: $( date )"
			update=0
			return
		fi

		msg "ERROR: manual restart failed: $( date )"
		msg "ERROR: attempting to roll-back: $( date )"

		cd "$nameddir"
		for view in $views; do
			for file in $( find "$view" -name ".bak-*" ); do
				res=$( echo "$file" | sed -e "s/.bak-//" )
				sudo mv "$file" "$res"
			done
		done
		cd - > /dev/null

		sudo service named start
		if pgrep named > /dev/null; then
			msg "Roll-back succeeded: $( date )"
			update=0
			return
		fi

		echo "$USER: $( date )" |
			mail -s "nsadmin: roll-back failed" "$critical"
		fatal "roll-back failed ... giving up" # NOTREACHED
		update=2

	fi

	update=0 # successful update/reload
}

# fatal
#
# Generate a fatal error message and exit this program.
#
fatal()
{
	logger -p user.crit -t "FATAL ERROR" "$*"
	echo
	echo " Fatal Error: $*" | tee -a "$log"
	echo
	exit 1
}

# msg
#
# Provide a supplied message to the user and the log file.
#
msg()
{
	logger -p user.info -t Info "$*"
	cat <<-EOF | tee -a "$log"

	 $*

	EOF
}

# sigquit
#
# Process a set of commands when a signal is caught by trap.
#
sigquit()
{
	local excl
	local file
	local res
	local skip
	local subj

	[ "$ransig" ] && return

	stty echo

	LESSSECURE=

	cd "$nsadmindir"

	if [ ${update:=0} -eq 1 ]; then
		msg "ERROR: nsadmin killed after changes were" \
		    "made to master files: rolling back"
		for file in .bak-*; do
			[ -e "$file" ] || continue
			res=$( echo "$file" | sed -e s/.bak-// )
			cp "$file" "$res" > /dev/null 2>&1
		done
		checkin
		subj="nsadmin: ERROR: $( date ): $USER"
	elif [ ${update:=0} -eq 2 ]; then
		msg "ERROR: nsadmin killed after files were" \
		    "updated in the NAMEDB directory: rolling back"
		for file in .bak-*; do
			[ -e "$file" ] || continue
			res=$( echo "$file" | sed -e s/.bak-// )
			cp "$file" "$res"
		done
		checkin
		msg "ERROR":" rolling back NAMEDB zone files"
		subj="nsadmin: ERROR: $( date ): $USER"
	else
		checkin
		subj="nsadmin: $( date ): $USER"
	fi

	echo
	echo >> "$log"
	echo "$sep" >> "$log"
	echo " Finished: $( date )" | tee -a "$log"
	echo "$sep" >> "$log"
	echo >> "$log"
	cat "$log" | mail -s "$subj" "$admin"

	sudo rm -rf "$lock" "$log" "$tmp" .bak-* .revunq .updzones .view*

	# XXX Save the older version in case of emergency.
	#sudo find "$nameddir" -name ".bak-*" -exec rm -f {} \;

	#
	# Make sure files are not left in a write state as it will
	# generate errors.
	#
	for file in *; do
		[ -e "$file" ] || continue
		skip=
		for excl in $exclude; do
			[ "$file" = "$excl" ] || continue
			skip=1
			break
		done
		[ "$skip" ] || chmod a-w "$file" > /dev/null 2>&1
	done

	cd - > /dev/null

	ransig=1
}

# zonemenu
#
# Print the list of zones and prompt for user selection.
#
zonemenu()
{
	local zone

	while :; do
		zonelist

		printf "\n Please choose a zone to"
		if [ "$editmode" ]; then
			printf " edit "
		elif [ "$sync" ]; then
			printf " sync "
		else
			printf " view "
		fi
		printf "or 'q' to quit: "
		read zone

		if [ "$zone" = Q ] || [ "$zone" = q ]; then
			break
		fi

		echo
		if [ ! "$zone" ] || [ ! -f "$zone" ]; then
			msg "Zone file not found: '$zone'"
			continue
		fi

		if [ "$editmode" ]; then
			cp "$zone" ".bak-$zone" > /dev/null 2>&1
			editmaster "$zone"
		elif [ "$sync" ]; then
			if [ "$updzones" ]; then
				if ( ! echo "$updzones" | egrep \
		    		    "(^| |	)$zone(	| |$)" \
		    		    > /dev/null 2>&1 ); then
					updzones="$updzones $zone"
				fi
			else
				updzones="$zone"
			fi
		else
			${PAGER:-less} "$zone"
		fi
	done
}

############################################################ ZONE FUNCTIONS
# Functions to interact with master files and generated zones

# checkin
#
# Using RCS, check in the edited and verified master files.
#
checkin()
{
	local cnt=1

	while eval [ \"\$colist_$cnt\" ]; do
		echo "$USER: $( date )" |
			eval ci -u \"\$colist_$cnt\" #? \> /dev/null 2\>\&1
		cnt=$(( $cnt + 1 ))
	done
}

# checkout file
#
# Using RCS, check out the master file for editing.
#
checkout()
{
	local cnt=1
	local file="$1"

	while eval [ \"\$colist_$cnt\" ]; do
		eval [ \"\$file\" = \"\$colist_$cnt\" ] && return
		cnt=$(( $cnt + 1 ))
	done

	eval colist_$cnt=\"\$file\"
	co -l "$file" > /dev/null 2>&1
}

# getsubnets file
#
# Get only the subnets that changed in the master file edit.
#
getsubnets()
{
	local file="$1"
	local subnet

	for subnet in $( rcsdiff -uq "$file" | awk 'NR>2&&sub(/^[+-]/,"")' |
		zone2rev.awk -v file=- -v list_subnets=1 )
	do
		# Only insert subnet if not existing in $subnets
		echo "$subnets" | grep -q "\\<$(
			echo "$subnet" | sed -e 's/\./\\&/g'
		)$subnet\\>" || subnets="$subnets $subnet"
	done
	subnets="${subnets# }"
}

# pushzones
#
# Update the Bind zone files with the finished master files.
#
pushzones()
{
	local cmd
	local file
	local res
	local slave
	local view

	cwd="$PWD"

#?	clear # Testing -- Parker
	cat <<-EOF
	$sep
	# nsadmin: Zone Push
	$sep

	EOF
	msg " Executing local Push:"

	msg "	Backing up previous versions: $( date )"
	cd "$nameddir"
	for view in $views; do
		for file in $( find "$view" -type f ! -name ".bak-*" ); do
			res=$( echo "$file" |
			    sed -e 's/\(.*\/\)\(.*\)/\1.bak-\2/' )
			sudo cp "$file" "$res"
		done
	done
	cd - > /dev/null

	msg "	Pushing local zones: $( date )"
	cd "$tmp"
	sudo chown -R "$binduser:$bindgroup" *
	sudo chmod -R g-w *
	find . -type f -exec sudo cp {} "$nameddir/{}" \;
	cd - > /dev/null

	msg "	Building zone tarball: $( date )"
	cd "$tmp"
	tar czf zone.tgz *
	cd - > /dev/null
#?	sleep 2 # Testing -- Parker

	for slave in $slaves; do
#?		clear # Testing -- Parker
		cat <<-EOF
		$sep
		# nsadmin: Zone Push
		$sep

		EOF
		msg " Executing remove push to $slave: $( date )"

		msg "	Copying zone tarball to $slave: $( date )"
		cmd="scp $scpopts $tmp/zone.tgz $user@$slave:tmp"
		sudo su - $user -c "$cmd"

		msg "	Executing push on $slave: $( date )"
		cmd="ssh $sshopts $slave"
		cmd="$cmd 'sudo /usr/local/bin/nsslave'"
		sudo su - $user -c "$cmd"

#?		sleep 2 # Testing -- Parker
	done
}

# verify file
#
# Verify changes in the zone files.
#
verify()
{
	local ans
	local file="$1"
	local res

	if rcsdiff -q "$file"; then
		ci -u "$file" > /dev/null 2>&1
		msg "No changes made to $file."
		stty -echo
		echo " Press return to continue."
		read ans # Ignored
		stty echo
		return
	fi

	if res=$( zone2rev.awk -v file="$file" -v verify=1 ); then
		vprompt "$file"
		return
	fi

#?	clear # Testing -- Parker
	cat <<-EOF
	$sep
	# nsadmin: Verify Failure
	$sep

	EOF

	msg "ERROR: incorrect A/AAAA record format"
	echo

	echo "$res" | tee -a "$log"
	rcsdiff -u "$file" | tee -a "$log"

	echo
	echo
	stty -echo
	echo " Press return to continue."
	read ans # Ignored
	stty echo

	editmaster "$file"
}

# viewtest zone
#
# Test the view syntax in the master files.
#
viewtest()
{
	local file="$nsadmindir/$1"
	local view

	cat <<-EOF

	 Testing View Syntax:

	EOF

	rm -f .view*

	grep --line-number VIEW "$file" > .view
	grep -v "; VIEW: " .view >> .view-out
	grep , .view | grep -v ", " >> .view-out

	grep "; VIEW: " .view |
		sed -e "s/.*VIEW: //;s/,//g" > .view-list
	for view in $views; do
		sed -e "s/$view//g" .view-list > .n
		mv .n .view-list
	done
	egrep -v '^( $|$)' .view-list > .n
	mv .n .view-list

	# XXX YUK
	if [ -s .view-out ] || [ -s .view-list ]; then
		if [ -s .view-out ]; then
			sed -e 's/^\([0-9]*\):/line \1: /;s/^/	/' .view-out
			echo
			msg "ERROR: invalid view syntax, must use" \
			    "'; VIEW: <view>[, <view> ...]'"
		fi

		if [ -s .view-list ]; then
			sed -e "s/^/	unknown view: /" .view-list
			echo
			msg "ERROR: unknown views, valid views are" "'$views'"
		fi

		failtype=master
		failfile="$1"

		return
	fi

	echo "	OK"
	echo
}

# vprompt file
#
# User interaction within the verify() function.
#
vprompt()
{
	local ans
	local file="$1"

	clear
	cat <<-EOF
	$sep
	# nsadmin: $file Changes
	$sep

	EOF

	rcsdiff -u "$file" | tee -a "$log"

	echo
	printf " Accept these changes [(y)es | (n)o | (E)dit]: "
	read ans
	echo

	case "$ans" in
	[nN])	msg "$USER canceled changes: $( date )"
		cp ".bak-$file" "$file" > /dev/null 2>&1
		;;
	[yY])	echo
		msg "$USER accepted changes: $( date )"
		getsubnets "$file"
		update=1 # First stage of dns updates
		if [ "$updzones" ] && ! echo "$updzones" |
		    egrep "(^| |	)$file(	| |$)" > /dev/null 2>&1
		then
			updzones="$updzones $file"
		else
			updzones="$file"
		fi
		echo
		;;
	*)	msg "$USER re-editing $file; $( date )"
		editmaster "$file"
	esac
}

# zonelist
#
# List the currently active zones.
#
zonelist()
{
	local cnt
	local col=0
	local tab=
	local zone

	clear

	cat <<-EOF
	$sep
	# nsadmin: Zone List
	$sep

	EOF

	for zone in [a-z0-9]*; do
		[ -e "$zone" ] || continue
		if echo "$exclude" |
		    egrep "(^| |	)$zone(	| |$)" \
		    > /dev/null 2>&1
		then
			continue
		fi

		cnt=$(( ${#zone} + 1 ))
		if [ $cnt -lt 8 ]; then
			tab='\t\t\t'
		elif [ $cnt -lt 16 ]; then
			tab='\t\t'
		else
			tab='\t'
		fi
		if [ $col -ge 3 ]; then
			echo
			col=0
		fi
		printf " %s$tab" "$zone"
		col=$(( $col + 1 ))
	done
	echo
}

# zonetest
#
# Test the generated zones and rev maps.
#
zonetest()
{
	local file
	local _IFS="$IFS" IFS
	local res

	failfile=
	failtype=

	for file in $( find "$tmp" -type f ); do
		IFS=/
		set -- ${file#"$tmp/"}
		IFS="$_IFS"

		clear
		cat <<-EOF
		$sep
		# nsadmin: Zone Tests
		$sep

		 View:	$1
		 Type:	$2
		 Zone:	$3

		EOF

		if [ "$2" = master ]; then
			viewtest "$3"
			[ "$failtype" ] && return
		fi

		echo
		echo " Testing Bind Syntax:"

		if ! res=$( exec 2>&1
			name="$3"
			if [ "$2" = rev ]; then
				if [ "$3" != "${3#*.*.*.*.*}" ]; then
					name="$name.ip6.arpa"
				else
					name="$name.in-addr.arpa"
				fi
			fi
			named-checkzone "$name" "$file"
		) && [ $( echo "$res" | wc -l ) -gt 2 ]; then
			failtype="$2"
			failfile="$3"

			echo "$res" | sed -e 's/.*\///;s/^/	/'
			echo

			echo
			echo " Master File Diff:"
			rcsdiff -u "$nsadmindir/$3" 2>&1 |
				sed -e "s/^/	/"
			echo

			msg "ERROR: zone test failed on $failfile"

			return
		fi

		echo "$res" | sed -e "s/^/	/"
		echo

#?		sleep 2 # Testing -- Parker
	done
}

############################################################ MAIN

# $USER is required for all logging and auditability.
[ "$USER" = root ] &&
	fatal "root is forbidden to use nsadmin" # NOTREACHED

#
# Process command-line options
#
while getopts "aehl:n:s?" flag; do
	case "$flag" in
	a) syncall=1 ;;
	e) editmode=1 ;;
	l) updzones=$( echo "$OPTARG" | sed -e "s/,/ /g" ) ;;
	n) slaves=$( echo "$OPTARG" | sed -e "s/,/ /g" ) ;;
	s) sync=1 ;;
	*) usage ;; # NOTREACHED
	esac
done

cd "$nsadmindir" || exit

if [ "$syncall" ]; then
	for file in *; do
		[ -e "$file" ] || continue
		skip=
		for excl in $exclude; do
			[ "$file" = "$excl" ] || continue
			skip=1
			break
		done
		if [ ! "$skip" ] && [ ! "$updzones" ]; then
			updzones="$file"
		elif [ ! "$skip" ]; then
			updzones="$updzones $file"
		fi
	done
fi

if [ "$updzones" ] && [ ! "$sync" ]; then
	msg "ERROR: '-l' or '-a' requires '-s'"
	usage # NOTREACHED
fi

umask 0022
LESSSECURE=1 # Disable edit functions

#
# Check for duplicate instances
#
pids=
for pid in $( pgrep -f "/bin/(ba)?sh $0([[:space:]]|$)" 2> /dev/null ); do
        case "$pid" in $$|$PPID) continue; esac
        ps -p $pid > /dev/null 2>&1 || continue
        pids="$pids $pid"
done
if [ "$pids" ]; then
        echo "Already running:" $pids
        exit $FAILURE
fi

# Make sure only one person is building zone files at a time
if [ "$editmode" ] || [ "$sync" ]; then
	getlock
	predit
fi

# Display zone menu unless -a/-l given
[ "$updzones" ] || zonemenu

#
# If there are changes to the master files, generate the zones
#
[ "$updzones" ] || exit $SUCCESS
if [ "$sync" ]; then
	msg "File generation called by sync option."
	msg "Files: $updzones"
else
	# We need a description of why this is being done
	( set -e
		tmpfile=$( mktemp -t "$pgm.XXXXXXXX" )
		awk 'sub(/^\t+/,"")||1' >> "$tmpfile" <<-EOF


		# Please enter some text describing your changes
		#
		# IMPORTANT! Lines beginning with # are ignored
		# IMPORTANT! Blank lines are ignored
		#
		# WARNING! Changes will be aborted without a message
		EOF
		trap 'rm -f "$tmpfile" > /dev/null 2>&1' EXIT
		${EDITOR:-vi} "$tmpfile"
		msg=$( awk '!/^[[:space:]]*(#|$)/' "$tmpfile" )
		cat "$log" > "$tmpfile"
		if [ ! "$msg" ]; then
			msg="WARNING! No message entered. Cancelling."
			echo "$msg" >&2
			echo "$msg" > "$log"
			echo >> "$log"
			cat "$tmpfile" >> "$log"
			exit $FAILURE
		fi
		echo "$msg" > "$log"
		echo >> "$log"
		cat "$tmpfile" >> "$log"
	) || exit
fi
genmaster
pushzones
dnsreload

exit $SUCCESS

################################################################################
# END
################################################################################
