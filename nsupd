#!/bin/sh
############################################################ IDENT(1)
#
# $Title: Script to make dynamic changes to nsadmin $
# $Copyright: 2019 Devin Teske. All rights reserved. $
# $FrauBSD: nsadmin/nsupd 2019-11-07 16:32:34 -0800 freebsdfrau $
#
############################################################ CONFIGURATION

# Supported commands with defined handlers
COMMANDS="add answer del delete send server update"

# Default timeout for ssh command used by send handler
DEFAULT_TIMEOUT=300

############################################################ GLOBALS

VERSION='$Version: 0.1.5 $'

pgm="${0##*/}" # Program basename

PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

#
# Global exit status
#
SUCCESS=0
FAILURE=1

#
# OS Glue
#
: ${UNAME_s:=$( uname -s )}

#
# Command-line options
#
DEBUG=0				# -d | -D
INTERACTIVE=1			# -i
LOCAL=				# -l
TIMEOUT=$DEFAULT_TIMEOUT	# -t timeout

#
# Command-line arguments
#
FILE=

#
# Miscellaneous
#
PROMPT="> "
SERVER=
UPDZONES=

############################################################ FUNCTIONS

debug(){ [ $DEBUG -gt 0 ] || return; printf "%s\n" "$*" >&2; }
xdebug(){ [ $DEBUG -eq 2 ] || return; printf "%s\n" "$*" >&2; }

die()
{
	local fmt="$1"
	if [ $# -gt 0 ]; then
		shift 1 # fmt
		printf "%s: $fmt\n" "$pgm" "$@" >&2
	fi
	exit $FAILURE
}

usage()
{
	local optfmt="\t%-16s %s\n"
	exec >&2
	if [ $# -gt 0 ]; then
		local fmt="$1"
		shift 1 # fmt
		printf "%s: $fmt\n" "$pgm" "$@"
	fi
	printf "Usage: %s [-dDhilV] [-t timeout] [ignored] [--] [filename]\n" \
		"$pgm"
	printf "Options:\n"
	printf "$optfmt" "-d" "Debug mode."
	printf "$optfmt" "-D" "Extra debug mode."
	printf "$optfmt" "-i" "Force interactive mode."
	printf "$optfmt" "-h" "Print usage statement and exit."
	printf "$optfmt" "-l" "Local-host only mode."
	printf "$optfmt" "-t timeout" \
		"Update timeout in seconds. Default $DEFAULT_TIMEOUT."
	printf "$optfmt" "-V" "Print version and exit."
	printf "Ignored Options (for compatibility):\n"
	printf "$optfmt" "-g" "Not implemented."
	printf "$optfmt" "-k keyfile" "Not implemented."
	printf "$optfmt" "-L level" "Not implemented."
	printf "$optfmt" "-o" "Not implemented."
	printf "$optfmt" "-p port" "Not implemented."
	printf "$optfmt" "-P" "Not implemented. Silently exits."
	printf "$optfmt" "-r udpretries" "Not implemented."
	printf "$optfmt" "-R randomdev" "Not implemented."
	printf "$optfmt" "-T" "Not implemented. Silently exits."
	printf "$optfmt" "-u udptimeout" "Not implemented."
	printf "$optfmt" "-v" "Not implemented."
	printf "$optfmt" "-y [hmac:]keyname:secret" ""
	printf "$optfmt" "" "Not implemented."
	die
}

# get_random [$var_to_set]
#
# Obtain a random number. If $var_to_set is NULL or missing, printed on stdout.
#
get_random()
{
	local var_to_set="$1"
	local dd="dd if=/dev/urandom of=/dev/stdout"
	local rand

	rand=$( awk -v dd="$dd 2> /dev/null" -v sample=256 '
		BEGIN {
			while (sample && dd | getline > 0)
				seed += int($0 sample--)
			close(dd)
			srand(seed)
			printf "%.0f\n", rand() * 65535
		}
	' )

	if [ "$var_to_set" ]; then
		eval $var_to_set=\"\$rand\"
	else
		echo "$rand"
	fi
}

# process_call $cmd [$args ...]
#
# Call the command-handler for $cmd.
#
process_call()
{
	local cmd="$1"

	shift 1 # cmd

	# Translate `-' to `_' if necessary
	case "$cmd" in
	*-*) cmd=$( echo "$cmd" | awk 'gsub(/-/,"_")||1' ) ;;
	esac

	eval handle_$cmd \"\$@\"
}

# process_one $cmd [$args ...]
#
# Process a single command.
#
process_one()
{
	local cmd="$1" args
	local found=

	[ $# -gt 0 ] && shift 1 # cmd

	# Check for invalid commands
	case "$cmd" in
	*[!a-zA-Z-]*|-*|*-)
		printf "%s: invalid command \`%s'\n" "$pgm" "$cmd" >&2
		if [ "$INTERACTIVE" ]; then
			return $SUCCESS # Non-fatal
		else
			return $FAILURE # Fatal
		fi
		;;
	esac

	# Convert to lower-case if necessary
	case "$cmd" in
	*[A-Z]*) cmd=$( echo "$cmd" | awk '{print tolower($0)}' ) ;;
	esac

	# Call command handler if implemented
	for c in $COMMANDS; do
		[ "$cmd" = "$c" ] || continue
		found=1
		break
	done
	if [ "$found" ]; then
		process_call "$cmd" "$@" || [ "$INTERACTIVE" ] || die
	else
		printf "%s: %s not implemented\n" \
			"$pgm" "$cmd" >&2
	fi

	return $SUCCESS # Non-fatal
}

# process_file $file
#
# Process all the lines in $file.
#
process_file()
{
	local file="$1"
	local cmd args

	[ "$file" = "-" ] && file=/dev/stdin
	while read cmd args; do
		process_one "$cmd" "$args" || break
	done < "$file" || die
}

# process_user
#
# Process input from user.
#
process_user()
{
	local cmd args

	xdebug "user_interaction()"

	while :; do
		printf "%s" "$PROMPT"
		read cmd args || break
		process_one "$cmd" "$args"
	done
}

# handle_add [$args ...]
#
# Shortcut to `handle_update add [$args ...]'
#
handle_add()
{
	handle_update add "$@"
}

# handle_answer [$args ...]
#
# Handler for the answer command.
#
handle_answer()
{
	local id
	local zone

	[ "$STATUS" ] || return

	# STATUS is NOERROR/REFUSED/NOTZONE/etc. (checked by foreman)
	get_random id

	printf "Answer:\n"
	printf ";; ->>HEADER<<- opcode: UPDATE, status: %s, id: %6u\n" \
		"${STATUS:-NOERROR}" "$id"
	printf ";; flags: qr; ZONE: 1, PREREQ: 0, UPDATE: 0, ADDITIONAL: 1\n"
	[ "$UPDZONES" ] && printf ";; ZONE SECTION:\n"
	for zone in $UPDZONES; do
		printf ";%s.\t\t\tIN\tSOA\n" "$zone"
	done
	printf "\n"

	# NB: Foreman does not need the TSIG PSEUDOSECTION

	return $SUCCESS # Non-fatal
}

# handle_del [$args ...]
#
# Shortcut to `handle_update del [$args ...]'
#
handle_del()
{
	handle_update del "$@"
}

# handle_delete [$args ...]
#
# Shortcut to `handle_update delete [$args ...]'
#
handle_delete()
{
	handle_update delete "$@"
}

# handle_send [$args ...]
#
# Handler for the send command.
#
handle_send()
{
	if [ "$LOCAL" ]; then
		send_local
	else
		send_server
	fi
}

# handle_server [$args ...]
#
# Handler for the server command.
#
handle_server()
{
	if [ "$LOCAL" ]; then
		echo "cannot reset server in localhost-only mode" >&2
		return
	fi

	SERVER="$1"
	# Remaining arguments silently ignored
}

# handle_update [$args ...]
#
# Handler for the update command.
#
handle_update()
{
	printf "%s: handle_update: Implementation pending\n" "$pgm" >&2

	return $SUCCESS # Non-fatal
}

# send_local
#
# Perform actions locally.
#
send_local()
{
	printf "%s: send_local: Implementation pending\n" "$pgm" >&2

	return $SUCCESS # Non-fatal
}

# send_server
#
# Perform actions on $SERVER.
#
send_server()
{
	local xtra=
	local output

	if [ $DEBUG -eq 1 ]; then
		xtra="$xtra -d"
	elif [ $DEBUG -eq 2 ]; then
		xtra="$xtra -D"
	fi
	
	echo "$INPUT" | awk '
		{ cmd = tolower($1) }
		cmd == "server" { next }
		{ print }
	' | ssh -oStrictHostKeyChecking=no \
		-oBatchMode=yes \
		-oPasswordAuthentication=no \
		"root@$SERVER" \
		/usr/local/bin/nsupd $xtra -l -

	return $SUCCESS
}

############################################################ MAIN

[ -t 0 ] || INTERACTIVE= # stdin is not a TTY

#
# Process command-line options
#
optign=gk:L:op:r:R:u:vy:
optignx=PT
while getopts dDihlt:V$optign$optignx flag; do
	case "$flag" in
	g|k|L|o|p|r|R|u|v|y) : ignored ;;
	D) [ $DEBUG -lt 2 ] && DEBUG=2 ;;
	d) [ $DEBUG -lt 1 ] && DEBUG=1 ;;
	P|T) exit $SUCCESS ;; # Not implemented
	i) INTERACTIVE=1 ;;
	l) LOCAL=1 ;;
	t) TIMEOUT="$OPTARG" ;;
	V) VERSION="${VERSION#*: }"
		echo "${VERSION% $}"
		exit $SUCCESS ;;
	*) usage # NOTREACHED
	esac
done
shift $(( $OPTIND - 1 ))

#
# Validate command-line options
#
case "$TIMEOUT" in
""|*[!0-9]*)
	usage "\`-t timeout' requires a numerical argument"
	;; # NOTREACHED
esac

xdebug "setup_system()"
xdebug "reset_system()"

#
# Process desired input
#
if [ $# -gt 0 ]; then
	FILE="$1"
	INTERACTIVE=
	process_file "$FILE"
elif [ ! "$INTERACTIVE" ]; then
	process_file /dev/stdin
else
	process_user
fi

xdebug "shutdown_program()"

exit $SUCCESS

################################################################################
# END
################################################################################
