#!/bin/sh
############################################################ IDENT(1)
#
# $Title: Script to make dynamic changes to nsadmin $
# $Copyright: 2019 Devin Teske. All rights reserved. $
# $FrauBSD: nsadmin/nsupd 2019-11-13 14:01:49 -0800 freebsdfrau $
#
############################################################ CONFIGURATION

# Supported commands with defined processors
COMMANDS="add answer del delete send server update zone"

# Default timeout for ssh command used by send processor
DEFAULT_TIMEOUT=300

# Default port for ssh command used by send processor
DEFAULT_PORT=22

# Default keyfile for ssh command used by send processor
DEFAULT_SSHKEY=~/.ssh/id_rsa

############################################################ GLOBALS

VERSION='$Version: 0.1.8 $'

pgm="${0##*/}" # Program basename

PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

#
# Global exit status
#
SUCCESS=0
FAILURE=1

#
# OS Glue
#
: ${UNAME_s:=$( uname -s )}

#
# Command-line options
#
DEBUG=0				# -d | -D
INTERACTIVE=1			# -i
LOCAL=				# -l
SSHKEY="$DEFAULT_SSHKEY"	# -k keyfile
TIMEOUT=$DEFAULT_TIMEOUT	# -t timeout

#
# Command-line arguments
#
FILE=

#
# Miscellaneous
#
INPUT=
NCMDS=0
PORT=$DEFAULT_PORT
PROMPT="> "
SERVER=
ZONE=

############################################################ FUNCTIONS

debug(){ [ $DEBUG -gt 0 ] || return; printf "%s\n" "$*" >&2; }
xdebug(){ [ $DEBUG -eq 2 ] || return; printf "%s\n" "$*" >&2; }

# die [$fmt [$args ...]]
#
# Optionally write a message to stderr before exiting with error status.
#
die()
{
	local fmt="$1"
	if [ $# -gt 0 ]; then
		shift 1 # fmt
		printf "$fmt\n" "$@" >&2
	fi
	exit $FAILURE
}

# usage [$fmt [$args ...]]
#
# Print usage statement and exit. Optional error message supported.
#
usage()
{
	local optfmt="\t%-16s %s\n"
	exec >&2
	if [ $# -gt 0 ]; then
		local fmt="$1"
		shift 1 # fmt
		printf "%s: $fmt\n" "$pgm" "$@"
	fi
	printf "Usage: %s [-dDhilV] %s [ignored] [--] [filename]\n" \
		"[-t timeout] [-p port]" "$pgm"
	printf "Options:\n"
	printf "$optfmt" "-d" "Debug mode."
	printf "$optfmt" "-D" "Extra debug mode."
	printf "$optfmt" "-h" "Print usage statement and exit."
	printf "$optfmt" "-i" "Force interactive mode."
	printf "$optfmt" "-k keyfile" "SSH key. Default $DEFAULT_SSHKEY."
	printf "$optfmt" "-l" "Local-host only mode."
	printf "$optfmt" "-p port" "Port to connect on. Default $DEFAULT_PORT."
	printf "$optfmt" "-t timeout" \
		"Update timeout in seconds. Default $DEFAULT_TIMEOUT."
	printf "$optfmt" "-V" "Print version and exit."
	printf "Ignored Options (for compatibility):\n"
	printf "$optfmt" "-g" "Not implemented."
	printf "$optfmt" "-L level" "Not implemented."
	printf "$optfmt" "-o" "Not implemented."
	printf "$optfmt" "-P" "Not implemented. Silently exits."
	printf "$optfmt" "-r udpretries" "Not implemented."
	printf "$optfmt" "-R randomdev" "Not implemented."
	printf "$optfmt" "-T" "Not implemented. Silently exits."
	printf "$optfmt" "-u udptimeout" "Not implemented."
	printf "$optfmt" "-v" "Not implemented."
	printf "$optfmt" "-y [hmac:]keyname:secret" ""
	printf "$optfmt" "" "Not implemented."
	die
}

# get_random [$var_to_set]
#
# Obtain a random number. If $var_to_set is NULL or missing, printed on stdout.
#
get_random()
{
	local var_to_set="$1"
	local dd="dd if=/dev/urandom of=/dev/stdout"
	local rand

	rand=$( awk -v dd="$dd 2> /dev/null" -v sample=256 '
		BEGIN {
			while (sample && dd | getline > 0)
				seed += int($0 sample--)
			close(dd)
			srand(seed)
			printf "%.0f\n", rand() * 65535
		}
	' )

	if [ "$var_to_set" ]; then
		eval $var_to_set=\"\$rand\"
	else
		echo "$rand"
	fi
}

# call_process $cmd [$args ...]
#
# Call the command-processor for $cmd.
#
call_process()
{
	local cmd="$1"

	shift 1 # cmd

	# Translate `-' to `_' if necessary
	case "$cmd" in
	*-*) cmd=$( echo "$cmd" | awk 'gsub(/-/,"_")||1' ) ;;
	esac

	process_$cmd "$@"
}

# one_process $cmd [$args ...]
#
# Process a single command.
#
one_process()
{
	local cmd="$1" args
	local found=

	[ $# -gt 0 ] && shift 1 # cmd

	# Check for invalid commands
	case "$cmd" in
	*[!a-zA-Z-]*|-*|*-)
		printf "%s: invalid command \`%s'\n" "$pgm" "$cmd" >&2
		if [ "$INTERACTIVE" ]; then
			return $SUCCESS # Non-fatal
		else
			return $FAILURE # Fatal
		fi
		;;
	esac

	# Convert to lower-case if necessary
	case "$cmd" in
	*[A-Z]*) cmd=$( echo "$cmd" | awk '{print tolower($0)}' ) ;;
	esac

	# Call command handler if implemented
	for c in $COMMANDS; do
		[ "$cmd" = "$c" ] || continue
		found=1
		break
	done
	if [ "$found" ]; then
		call_process "$cmd" "$@" || [ "$INTERACTIVE" ] || die
	else
		printf "%s: %s not implemented\n" \
			"$pgm" "$cmd" >&2
	fi

	return $SUCCESS # Non-fatal
}

# file_process $file
#
# Process all the lines in $file.
#
file_process()
{
	local file="$1"
	local cmd args

	[ "$file" = "-" ] && file=/dev/stdin
	while read cmd args; do
		one_process "$cmd" "$args" || break
	done < "$file" || die
}

# user_process
#
# Process input from user.
#
user_process()
{
	local cmd args

	while :; do
		printf "%s" "$PROMPT"
		read cmd args || break
		one_process "$cmd" "$args"
		xdebug "do_next_command()"
	done
}

# send_local
#
# Perform local actions.
#
send_local()
{
	local n=0
	local cmd
	local func

	while [ $n -lt $NCMDS ]; do
		n=$(( $n + 1 ))
		eval set -- \$cmd$n \$args$n
		[ $# -gt 0 ] || continue
		cmd="$1"
		shift 1 # cmd
		handler_$cmd "$@"
	done

	NCMDS=0

	return $SUCCESS # Non-fatal
}

# send_server
#
# Perform actions on $SERVER.
#
send_server()
{
	local xtra=
	local output

	if [ $DEBUG -eq 1 ]; then
		xtra="$xtra -d"
	elif [ $DEBUG -eq 2 ]; then
		xtra="$xtra -D"
	fi
	
	echo "$INPUT" | awk '
		$1 == "server" { next }
		{ print }
	' | ssh -oStrictHostKeyChecking=no \
		-oBatchMode=yes \
		-oPasswordAuthentication=no \
		-i "$SSHKEY" \
		"root@$SERVER" \
		/usr/local/bin/nsupd $xtra -l -

	return $SUCCESS
}

############################################################ CMD PROCESSORS
# Called when command defined in COMMANDS is encountered

# process_add [$args ...]
#
# Shortcut to `process_update add [$args ...]'
#
process_add()
{
	process_update add "$@"
}

# process_answer
#
# Processor for the answer command.
#
process_answer()
{
	handle_answer
}

# process_del [$args ...]
#
# Shortcut to `process_update del [$args ...]'
#
process_del()
{
	process_update delete "$@"
}

# process_delete [$args ...]
#
# Shortcut to `process_update delete [$args ...]'
#
process_delete()
{
	process_update delete "$@"
}

# process_send [$args ...]
#
# Processor for the send command.
#
process_send()
{
	if [ "$LOCAL" ]; then
		send_local
	else
		send_server
	fi
}

# process_server $server [$port]
#
# Processor for the server command.
#
process_server()
{
	if [ "$LOCAL" ]; then
		echo "cannot reset server in localhost-only mode" >&2
		return
	fi

	SERVER="$1"
	PORT="${2:-$DEFAULT_PORT}"
	# Remaining arguments silently ignored
}

# process_update [$args ...]
#
# Processor for the update command.
#
process_update()
{
	printf "%s: process_update: Implementation pending\n" "$pgm" >&2

	return $SUCCESS # Non-fatal
}

# process_zone $zone
#
# Processor for the zone command.
#
process_zone()
{
	local zone="$1"

	if [ ! "$zone" ]; then
		echo "could not read zone name" >&2
		return
	fi

	ZONE="$1"
}

############################################################ CMD HANDLERS
# Called when handling commands stored by processors
# NB: Not all processors store commands.

# handle_update [$args ...]
#
# Handler for the update command.
#
handle_update()
{
	printf "%s: handle_update: Implementation pending\n" "$pgm" >&2

	return $SUCCESS # Non-fatal
}

# handle_answer
#
# Handler for the answer command.
#
handle_answer()
{
	local id
	local zone

	[ "$STATUS" ] || return

	# STATUS is NOERROR/REFUSED/NOTZONE/etc. (checked by foreman)
	get_random id

	printf "Answer:\n"
	printf ";; ->>HEADER<<- opcode: UPDATE, status: %s, id: %6u\n" \
		"${STATUS:-NOERROR}" "$id"
	printf ";; flags: qr; ZONE: 1, PREREQ: 0, UPDATE: 0, ADDITIONAL: 1\n"
	printf ";; ZONE SECTION:\n"
	printf ";%s.\t\t\tIN\tSOA\n" "$ZONE"
	printf "\n"

	# NB: Foreman does not need the TSIG PSEUDOSECTION

	return $SUCCESS # Non-fatal
}

############################################################ MAIN

[ -t 0 ] || INTERACTIVE= # stdin is not a TTY

#
# Process command-line options
#
optign=gL:or:R:u:vy:
optignx=PT
while getopts dDhik:lp:t:V$optign$optignx flag; do
	case "$flag" in
	g|L|o|r|R|u|v|y) : ignored ;;
	d) [ $DEBUG -lt 1 ] && DEBUG=1 ;;
	D) [ $DEBUG -lt 2 ] && DEBUG=2 ;;
	p) PORT="$OPTARG" ;;
	P|T) exit $SUCCESS ;; # Not implemented
	i) INTERACTIVE=1 ;;
	k) SSHKEY="$OPTARG" ;;
	l) LOCAL=1 ;;
	t) TIMEOUT="$OPTARG" ;;
	V) VERSION="${VERSION#*: }"
		echo "${VERSION% $}"
		exit $SUCCESS ;;
	*) usage # NOTREACHED
	esac
done
shift $(( $OPTIND - 1 ))

#
# Validate command-line options
#
xdebug "setup_system()"
[ "$LOCAL" -o -e "$SSHKEY" ] ||
	die "can't read key from %s: file not found\n" "$SSHKEY"
case "$TIMEOUT" in ""|*[!0-9]*) die "bad timeout '%s'" "$TIMEOUT" ;; esac
case "$PORT" in ""|*[!0-9]*) die "bad port number '%s'" "$PORT" ;; esac
xdebug "reset_system()"

#
# Process desired input
#
xdebug "user_interaction()"
if [ $# -gt 0 ]; then
	FILE="$1"
	INTERACTIVE=
	file_process "$FILE"
elif [ ! "$INTERACTIVE" ]; then
	file_process /dev/stdin
else
	user_process
fi

xdebug "shutdown_program()"
exit $SUCCESS

################################################################################
# END
################################################################################
